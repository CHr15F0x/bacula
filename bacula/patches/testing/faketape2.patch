Index: src/baconfig.h
===================================================================
--- src/baconfig.h	(revision 7116)
+++ src/baconfig.h	(working copy)
@@ -86,12 +86,6 @@
 void InitWinAPIWrapper();
 
 #define  OSDependentInit()    InitWinAPIWrapper()
-#define  tape_open            win32_tape_open
-#define  tape_ioctl           win32_tape_ioctl
-#define  tape_read            win32_tape_read
-#define  tape_write           win32_tape_write
-#define  tape_close           win32_tape_close
-#define  IS_TAPE(x)           S_ISCHR(x)
 
 #define sbrk(x)  0
 
@@ -117,22 +111,6 @@
 
 #define  OSDependentInit()
 
-#if defined(USE_FAKETAPE)
-#  define  tape_open            faketape_open
-#  define  tape_ioctl           faketape_ioctl
-#  define  tape_read            faketape_read
-#  define  tape_write           faketape_write
-#  define  tape_close           faketape_close
-#  define  IS_TAPE(x)           S_ISREG(x)
-#else  /* UNIX && !FAKETAPE */
-#  define  tape_open            ::open
-#  define  tape_ioctl           ::ioctl
-#  define  tape_read            ::read
-#  define  tape_write           ::write
-#  define  tape_close           ::close
-#  define  IS_TAPE(x)           S_ISCHR(x)
-#endif
-
 #endif /* HAVE_WIN32 */
 
 
Index: src/stored/stored.h
===================================================================
--- src/stored/stored.h	(revision 7116)
+++ src/stored/stored.h	(working copy)
@@ -78,10 +78,9 @@
 int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);
 #endif
 
-#ifdef USE_FAKETAPE
-# include "faketape.h"
-#endif
+#include "faketape.h"
 
+
 /* Daemon globals from stored.c */
 extern STORES *me;                    /* "Global" daemon resource */
 extern bool forge_on;                 /* proceed inspite of I/O errors */
Index: src/stored/stored_conf.c
===================================================================
--- src/stored/stored_conf.c	(revision 7116)
+++ src/stored/stored_conf.c	(working copy)
@@ -213,6 +213,7 @@
    {"dvd",           B_DVD_DEV},
    {"fifo",          B_FIFO_DEV},
    {"vtl",           B_VTL_DEV},
+   {"faketape",      B_FAKETAPE_DEV},
    {NULL,            0}
 };
 
Index: src/stored/btape.c
===================================================================
--- src/stored/btape.c	(revision 7116)
+++ src/stored/btape.c	(working copy)
@@ -2504,11 +2504,7 @@
    Pmsg1(0, _("Begin writing raw blocks of %u bytes.\n"), block->buf_len);
    for ( ;; ) {
       *p = block_num;
-      if (dev->is_tape()) {
-         stat = tape_write(dev->fd(), block->buf, block->buf_len);
-      } else {
-         stat = write(dev->fd(), block->buf, block->buf_len);
-      }
+      stat = dev->d_write(dev->fd(), block->buf, block->buf_len);
       if (stat == (int)block->buf_len) {
          if ((block_num++ % 100) == 0) {
             printf("+");
Index: src/stored/dev.c
===================================================================
--- src/stored/dev.c	(revision 7116)
+++ src/stored/dev.c	(working copy)
@@ -123,10 +123,17 @@
       }
       if (S_ISDIR(statp.st_mode)) {
          device->dev_type = B_FILE_DEV;
-      } else if (IS_TAPE(statp.st_mode)) { /* char device or fake tape */
+      } else if (S_ISCHR(statp.st_mode)) {
          device->dev_type = B_TAPE_DEV;
       } else if (S_ISFIFO(statp.st_mode)) {
          device->dev_type = B_FIFO_DEV;
+#ifdef USE_FAKETAPE
+      /* must set DeviceType = Faketape 
+       * in normal mode, autodetection is disabled
+       */
+      } else if (S_ISREG(statp.st_mode)) { 
+         device->dev_type = B_FAKETAPE_DEV;
+#endif
       } else if (!(device->cap_bits & CAP_REQMOUNT)) {
          Jmsg2(jcr, M_ERROR, 0, _("%s is an unknown device type. Must be tape or directory\n"
                " or have RequiresMount=yes for DVD. st_mode=%x\n"),
@@ -162,6 +169,7 @@
    dev->drive_index = device->drive_index;
    dev->autoselect = device->autoselect;
    dev->dev_type = device->dev_type;
+   dev->init_backend();
    if (dev->is_tape()) { /* No parts on tapes */
       dev->max_part_size = 0;
    } else {
@@ -264,6 +272,34 @@
    return dev;
 }
 
+/* Choose the right backend */
+void DEVICE::init_backend()
+{
+   if (is_faketape()) {
+      d_open  = faketape_open;
+      d_write = faketape_write;
+      d_close = faketape_close;
+      d_ioctl = faketape_ioctl;
+      d_read  = faketape_read;
+
+#ifdef HAVE_WIN32
+   } else if (is_tape()) {
+      d_open  = win32_tape_open;
+      d_write = win32_tape_write;
+      d_close = win32_tape_close;
+      d_ioctl = win32_tape_ioctl;
+      d_read  = win32_tape_read;
+#endif
+
+   } else {
+      d_open  = ::open;
+      d_write = ::write;
+      d_close = ::close;
+      d_ioctl = ::ioctl;
+      d_read  = ::read;
+   }
+}
+
 /*
  * Open the device with the operating system and
  * initialize buffer pointers.
@@ -285,11 +321,7 @@
       if (openmode == omode) {
          return m_fd;
       } else {
-         if (is_tape()) {
-            tape_close(m_fd);
-         } else {
-            ::close(m_fd);
-         }
+         d_close(m_fd);
          clear_opened();
          Dmsg0(100, "Close fd for mode change.\n");
          preserve = state & (ST_LABEL|ST_APPEND|ST_READ);
@@ -368,7 +400,7 @@
 #if defined(HAVE_WIN32)
 
    /*   Windows Code */
-   if ((m_fd = tape_open(dev_name, mode)) < 0) {
+   if ((m_fd = d_open(dev_name, mode)) < 0) {
       dev_errno = errno;
    }
 
@@ -378,7 +410,7 @@
    /* If busy retry each second for max_open_wait seconds */
    for ( ;; ) {
       /* Try non-blocking open */
-      m_fd = tape_open(dev_name, mode+O_NONBLOCK);
+      m_fd = d_open(dev_name, mode+O_NONBLOCK);
       if (m_fd < 0) {
          berrno be;
          dev_errno = errno;
@@ -390,10 +422,10 @@
          mt_com.mt_op = MTREW;
          mt_com.mt_count = 1;
          /* rewind only if dev is a tape */
-         if (is_tape() && (tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com) < 0)) {
+         if (is_tape() && (d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com) < 0)) {
             berrno be;
             dev_errno = errno;           /* set error status from rewind */
-            tape_close(m_fd);
+            d_close(m_fd);
             clear_opened();
             Dmsg2(100, "Rewind error on %s close: ERR=%s\n", print_name(),
                   be.bstrerror(dev_errno));
@@ -403,8 +435,8 @@
             }
          } else {
             /* Got fd and rewind worked, so we must have medium in drive */
-            tape_close(m_fd);
-            m_fd = tape_open(dev_name, mode);  /* open normally */
+            d_close(m_fd);
+            m_fd = d_open(dev_name, mode);  /* open normally */
             if (m_fd < 0) {
                berrno be;
                dev_errno = errno;
@@ -688,7 +720,7 @@
                be.bstrerror());
          Dmsg1(100, "open failed: %s", errmsg);
          /* Use system close() */
-         ::close(m_fd);
+         d_close(m_fd);
          clear_opened();
       } else {
          part_size = filestat.st_size;
@@ -732,7 +764,7 @@
        * retrying every 5 seconds.
        */
       for (i=max_rewind_wait; ; i -= 5) {
-         if (tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com) < 0) {
+         if (d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com) < 0) {
             berrno be;
             clrerror(MTREW);
             if (i == max_rewind_wait) {
@@ -746,7 +778,7 @@
              */
             if (first && dcr) {
                int open_mode = openmode;
-               tape_close(m_fd);
+               d_close(m_fd);
                clear_opened();
                open(dcr, open_mode);
                if (m_fd < 0) {
@@ -886,7 +918,7 @@
          mt_com.mt_count = 1;
       }
 
-      if (tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com) < 0) {
+      if (d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com) < 0) {
          berrno be;
          clrerror(mt_com.mt_op);
          Dmsg1(50, "ioctl error: %s\n", be.bstrerror());
@@ -1030,7 +1062,7 @@
       stat |= BMT_TAPE;
       Pmsg0(-20,_(" Bacula status:"));
       Pmsg2(-20,_(" file=%d block=%d\n"), dev->file, dev->block_num);
-      if (tape_ioctl(dev->fd(), MTIOCGET, (char *)&mt_stat) < 0) {
+      if (dev->d_ioctl(dev->fd(), MTIOCGET, (char *)&mt_stat) < 0) {
          berrno be;
          dev->dev_errno = errno;
          Mmsg2(dev->errmsg, _("ioctl MTIOCGET error on %s. ERR=%s.\n"),
@@ -1157,7 +1189,7 @@
    dev->file_addr = 0;
    mt_com.mt_op = MTLOAD;
    mt_com.mt_count = 1;
-   if (tape_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
+   if (dev->d_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
       berrno be;
       dev->dev_errno = errno;
       Mmsg2(dev->errmsg, _("ioctl MTLOAD error on %s. ERR=%s.\n"),
@@ -1188,7 +1220,7 @@
    unlock_door();
    mt_com.mt_op = MTOFFL;
    mt_com.mt_count = 1;
-   if (tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com) < 0) {
+   if (d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com) < 0) {
       berrno be;
       dev_errno = errno;
       Mmsg2(errmsg, _("ioctl MTOFFL error on %s. ERR=%s.\n"),
@@ -1263,7 +1295,7 @@
       int my_errno = 0;
       mt_com.mt_op = MTFSF;
       mt_com.mt_count = num;
-      stat = tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
+      stat = d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
       if (stat < 0) {
          my_errno = errno;            /* save errno */
       } else if ((os_file=get_os_tape_file()) < 0) {
@@ -1344,7 +1376,7 @@
          }
 
          Dmsg0(100, "Doing MTFSF\n");
-         stat = tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
+         stat = d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
          if (stat < 0) {                 /* error => EOT */
             berrno be;
             set_eot();
@@ -1418,7 +1450,7 @@
    file_size = 0;
    mt_com.mt_op = MTBSF;
    mt_com.mt_count = num;
-   stat = tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
+   stat = d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
    if (stat < 0) {
       berrno be;
       clrerror(MTBSF);
@@ -1458,7 +1490,7 @@
    Dmsg1(100, "fsr %d\n", num);
    mt_com.mt_op = MTFSR;
    mt_com.mt_count = num;
-   stat = tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
+   stat = d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
    if (stat == 0) {
       clear_eof();
       block_num += num;
@@ -1517,7 +1549,7 @@
    clear_eot();
    mt_com.mt_op = MTBSR;
    mt_com.mt_count = num;
-   stat = tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
+   stat = d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
    if (stat < 0) {
       berrno be;
       clrerror(MTBSR);
@@ -1533,7 +1565,7 @@
    struct mtop mt_com;
    mt_com.mt_op = MTLOCK;
    mt_com.mt_count = 1;
-   tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
+   d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
 #endif
 }
 
@@ -1543,7 +1575,7 @@
    struct mtop mt_com;
    mt_com.mt_op = MTUNLOCK;
    mt_com.mt_count = 1;
-   tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
+   d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
 #endif
 }
 
@@ -1668,7 +1700,7 @@
    clear_eot();
    mt_com.mt_op = MTWEOF;
    mt_com.mt_count = num;
-   stat = tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
+   stat = d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
    if (stat == 0) {
       block_num = 0;
       file += num;
@@ -1799,7 +1831,7 @@
 /* Found on Solaris */
 #ifdef MTIOCLRERR
 {
-   tape_ioctl(m_fd, MTIOCLRERR);
+   d_ioctl(m_fd, MTIOCLRERR);
    Dmsg0(200, "Did MTIOCLRERR\n");
 }
 #endif
@@ -1812,7 +1844,7 @@
    union mterrstat mt_errstat;
    Dmsg2(200, "Doing MTIOCERRSTAT errno=%d ERR=%s\n", dev_errno,
       be.bstrerror(dev_errno));
-   tape_ioctl(m_fd, MTIOCERRSTAT, (char *)&mt_errstat);
+   d_ioctl(m_fd, MTIOCERRSTAT, (char *)&mt_errstat);
 }
 #endif
 
@@ -1823,7 +1855,7 @@
    mt_com.mt_op = MTCSE;
    mt_com.mt_count = 1;
    /* Clear any error condition on the tape */
-   tape_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
+   d_ioctl(m_fd, MTIOCTOP, (char *)&mt_com);
    Dmsg0(200, "Did MTCSE\n");
 }
 #endif
@@ -1860,10 +1892,8 @@
    case B_VTL_DEV:
    case B_TAPE_DEV:
       unlock_door(); 
-      tape_close(m_fd);
-      break;
    default:
-      ::close(m_fd);
+      d_close(m_fd);
    }
 
    /* Clean up device packet so it can be reused */
@@ -2262,11 +2292,7 @@
 
    get_timer_count();
 
-   if (this->is_tape()) {
-      read_len = tape_read(m_fd, buf, len);
-   } else {
-      read_len = ::read(m_fd, buf, len);
-   }
+   read_len = d_read(m_fd, buf, len);
 
    last_tick = get_timer_count();
 
@@ -2287,11 +2313,7 @@
 
    get_timer_count();
 
-   if (this->is_tape()) {
-      write_len = tape_write(m_fd, buf, len);
-   } else {
-      write_len = ::write(m_fd, buf, len);
-   }
+   write_len = d_write(m_fd, buf, len);
 
    last_tick = get_timer_count();
 
@@ -2317,7 +2339,7 @@
    struct mtget mt_stat;
 
    if (has_cap(CAP_MTIOCGET) &&
-       tape_ioctl(m_fd, MTIOCGET, (char *)&mt_stat) == 0) {
+       d_ioctl(m_fd, MTIOCGET, (char *)&mt_stat) == 0) {
       return mt_stat.mt_fileno;
    }
    return -1;
@@ -2442,7 +2464,7 @@
       mt_com.mt_op = MTSETBLK;
       mt_com.mt_count = 0;
       Dmsg0(100, "Set block size to zero\n");
-      if (tape_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
+      if (dev->d_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
          dev->clrerror(MTSETBLK);
       }
    }
@@ -2458,7 +2480,7 @@
          mt_com.mt_count |= MT_ST_FAST_MTEOM;
       }
       Dmsg0(100, "MTSETDRVBUFFER\n");
-      if (tape_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
+      if (dev->d_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
          dev->clrerror(MTSETDRVBUFFER);
       }
    }
@@ -2472,13 +2494,13 @@
        dev->min_block_size == 0) {    /* variable block mode */
       mt_com.mt_op = MTSETBSIZ;
       mt_com.mt_count = 0;
-      if (tape_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
+      if (dev->d_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
          dev->clrerror(MTSETBSIZ);
       }
       /* Get notified at logical end of tape */
       mt_com.mt_op = MTEWARN;
       mt_com.mt_count = 1;
-      if (tape_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
+      if (dev->d_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
          dev->clrerror(MTEWARN);
       }
    }
@@ -2491,7 +2513,7 @@
        dev->min_block_size == 0) {    /* variable block mode */
       mt_com.mt_op = MTSETBSIZ;
       mt_com.mt_count = 0;
-      if (tape_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
+      if (dev->d_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
          dev->clrerror(MTSETBSIZ);
       }
    }
@@ -2502,7 +2524,7 @@
    } else {
       neof = 1;
    }
-   if (tape_ioctl(dev->fd(), MTIOCSETEOTMODEL, (caddr_t)&neof) < 0) {
+   if (dev->d_ioctl(dev->fd(), MTIOCSETEOTMODEL, (caddr_t)&neof) < 0) {
       berrno be;
       dev->dev_errno = errno;         /* save errno */
       Mmsg2(dev->errmsg, _("Unable to set eotmodel on device %s: ERR=%s\n"),
@@ -2519,7 +2541,7 @@
        dev->min_block_size == 0) {    /* variable block mode */
       mt_com.mt_op = MTSRSZ;
       mt_com.mt_count = 0;
-      if (tape_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
+      if (dev->d_ioctl(dev->fd(), MTIOCTOP, (char *)&mt_com) < 0) {
          dev->clrerror(MTSRSZ);
       }
    }
@@ -2531,7 +2553,7 @@
 {
    Dmsg0(100, "dev_get_os_pos\n");
    return dev->has_cap(CAP_MTIOCGET) && 
-          tape_ioctl(dev->fd(), MTIOCGET, (char *)mt_stat) == 0 &&
+          dev->d_ioctl(dev->fd(), MTIOCGET, (char *)mt_stat) == 0 &&
           mt_stat->mt_fileno >= 0;
 }
 
Index: src/stored/faketape.c
===================================================================
--- src/stored/faketape.c	(revision 7116)
+++ src/stored/faketape.c	(working copy)
@@ -60,7 +60,6 @@
 #include "bacula.h"             /* define 64bit file usage */
 #include "stored.h"
 
-#ifdef USE_FAKETAPE
 #include "faketape.h"
 
 static int dbglevel = 100;
@@ -992,4 +991,3 @@
          atEOF, atEOT, atEOD, atBOT);  
 }
 
-#endif /* USE_FAKETAPE */
Index: src/stored/dev.h
===================================================================
--- src/stored/dev.h	(revision 7116)
+++ src/stored/dev.h	(working copy)
@@ -95,7 +95,8 @@
    B_TAPE_DEV,
    B_DVD_DEV,
    B_FIFO_DEV,
-   B_VTL_DEV 
+   B_FAKETAPE_DEV,		/* change to B_TAPE_DEV after init */
+   B_VTL_DEV
 };
 
 /* Generic status bits returned from status_dev() */
@@ -307,11 +308,13 @@
    int is_autochanger() const { return capabilities & CAP_AUTOCHANGER; }
    int requires_mount() const { return capabilities & CAP_REQMOUNT; }
    int is_removable() const { return capabilities & CAP_REM; }
-   int is_tape() const { return dev_type == B_TAPE_DEV; }
+   int is_tape() const { return (dev_type == B_TAPE_DEV || 
+                                 dev_type == B_FAKETAPE_DEV); }
    int is_file() const { return dev_type == B_FILE_DEV; }
    int is_fifo() const { return dev_type == B_FIFO_DEV; }
    int is_dvd() const  { return dev_type == B_DVD_DEV; }
    int is_vtl() const  { return dev_type == B_VTL_DEV; }
+   int is_faketape() const  { return dev_type == B_FAKETAPE_DEV; }
    int is_open() const { return m_fd >= 0; }
    int is_offline() const { return state & ST_OFFLINE; }
    int is_labeled() const { return state & ST_LABEL; }
@@ -426,6 +429,14 @@
    uint32_t get_block_num() const { return block_num; };
    int fd() const { return m_fd; };
 
+   /* low level operations */
+   void init_backend();
+   int (*d_open)(const char *pathname, int flags, ...);
+   int (*d_read)(int fd, void *buffer, unsigned int count);
+   int (*d_write)(int fd, const void *buffer, unsigned int count);
+   int (*d_close)(int fd);
+   int (*d_ioctl)(int fd, unsigned long int request, ...);
+
    /* 
     * Locking and blocking calls
     */
Index: src/stored/faketape.h
===================================================================
--- src/stored/faketape.h	(revision 7116)
+++ src/stored/faketape.h	(working copy)
@@ -38,8 +38,6 @@
 #include <stddef.h>
 #include "bacula.h"
 
-#ifdef USE_FAKETAPE
-
 #define FTAPE_MAX_DRIVE 50
 
 /* 
@@ -85,7 +83,7 @@
    void check_eof() { if(needEOF) weof();};
    void update_pos();
    bool read_fm(FT_READ_FM_MODE readfirst);
-   void set_eot() { eot_count=0; atEOT=true;};
+   void set_eot() { atEOT=true;};
 
 public:
    int fsf();
@@ -109,5 +107,4 @@
    int tape_pos(struct mtpos *mt_com);
 };
 
-#endif /* USE_FAKETAPE */
 #endif /* !FAKETAPE_H */
Index: src/version.h
===================================================================
--- src/version.h	(revision 7116)
+++ src/version.h	(working copy)
@@ -62,7 +62,7 @@
  *  run regress test.
  */
 #ifdef DEVELOPER
-//#define USE_FAKETAPE
+#define USE_FAKETAPE
 #endif
 
 /* 
