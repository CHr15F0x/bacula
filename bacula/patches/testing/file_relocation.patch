Index: src/dird/ua_restore.c
===================================================================
--- src/dird/ua_restore.c	(révision 4466)
+++ src/dird/ua_restore.c	(copie de travail)
@@ -43,8 +43,8 @@
 
 #include "bacula.h"
 #include "dird.h"
+#include "lib/breg.h"
 
-
 /* Imported functions */
 extern void print_bsr(UAContext *ua, RBSR *bsr);
 
@@ -83,6 +83,10 @@
    JCR *jcr = ua->jcr;
    char *escaped_bsr_name = NULL;
    char *escaped_where_name = NULL;
+   bool where_use_regexp = false;
+   bool have_to_free_where = false;
+   char *strip_prefix, *add_prefix, *add_suffix;
+   strip_prefix = add_prefix = add_suffix = NULL;
 
    memset(&rx, 0, sizeof(rx));
    rx.path = get_pool_memory(PM_FNAME);
@@ -94,6 +98,41 @@
    i = find_arg_with_value(ua, "where");
    if (i >= 0) {
       rx.where = ua->argv[i];
+   }
+
+   i = find_arg_with_value(ua, "strip_prefix");
+   if (i >= 0) {
+      strip_prefix = ua->argv[i];
+   }
+
+   i = find_arg_with_value(ua, "add_prefix");
+   if (i >= 0) {
+      add_prefix = ua->argv[i];
+   }
+
+   i = find_arg_with_value(ua, "add_suffix");
+   if (i >= 0) {
+      add_suffix = ua->argv[i];
+   }
+
+   i = find_arg(ua, "where_use_regexp");
+   if (i >= 0) {
+      where_use_regexp = true;
+   }
+
+   i = find_arg_with_value(ua, "rwhere");
+   if (i >= 0) {
+      where_use_regexp = true;
+      rx.where = ua->argv[i];
+   }
+
+   if (strip_prefix || add_suffix || add_prefix) {
+      where_use_regexp = true;
+      have_to_free_where = true;
+      rx.where = bregexp_build_where(strip_prefix, add_prefix, add_suffix);
+   }
+
+   if (rx.where) {
       if (!acl_access_ok(ua, Where_ACL, rx.where)) {
          ua->error_msg(_("\"where\" specification not authorized.\n"));
          goto bail_out;
@@ -195,9 +234,10 @@
 
       Mmsg(ua->cmd,
           "run job=\"%s\" client=\"%s\" storage=\"%s\" bootstrap=\"%s\""
-          " where=\"%s\" files=%d catalog=\"%s\"",
+          " %swhere=\"%s\" files=%d catalog=\"%s\"",
           job->name(), rx.ClientName, rx.store?rx.store->name():"",
           escaped_bsr_name ? escaped_bsr_name : jcr->RestoreBootstrap,
+	  where_use_regexp ? "r" : "",
           escaped_where_name ? escaped_where_name : rx.where,
           rx.selected_files, ua->catalog->name());
    } else {
@@ -216,6 +256,10 @@
    if (escaped_where_name != NULL) {
       bfree(escaped_where_name);
    }
+   
+   if (have_to_free_where) {
+      free_pool_memory(rx.where);
+   }
 
    if (find_arg(ua, NT_("yes")) > 0) {
       pm_strcat(ua->cmd, " yes");    /* pass it on to the run command */
@@ -235,6 +279,10 @@
       bfree(escaped_where_name);
    }
 
+   if (have_to_free_where) {
+      free_pool_memory(rx.where);
+   }
+
    free_rx(&rx);
    return 0;
 
@@ -331,23 +379,28 @@
 
    const char *kw[] = {
        /* These keywords are handled in a for loop */
-      "jobid",     /* 0 */
-      "current",   /* 1 */
-      "before",    /* 2 */
-      "file",      /* 3 */
-      "directory", /* 4 */
-      "select",    /* 5 */
-      "pool",      /* 6 */
-      "all",       /* 7 */
+      "jobid",       /* 0 */
+      "current",     /* 1 */
+      "before",      /* 2 */
+      "file",        /* 3 */
+      "directory",   /* 4 */
+      "select",      /* 5 */
+      "pool",        /* 6 */
+      "all",         /* 7 */
 
       /* The keyword below are handled by individual arg lookups */
-      "client",    /* 8 */
-      "storage",   /* 9 */
-      "fileset",   /* 10 */
-      "where",     /* 11 */
-      "yes",       /* 12 */
-      "bootstrap", /* 13 */
-      "done",      /* 14 */
+      "client",       /* 8 */
+      "storage",      /* 9 */
+      "fileset",      /* 10 */
+      "where",        /* 11 */
+      "yes",          /* 12 */
+      "bootstrap",    /* 13 */
+      "done",         /* 14 */
+      "strip_prefix", /* 15 */
+      "add_prefix",   /* 16 */
+      "add_suffix",   /* 17 */
+      "where_use_regexp",/* 18 */
+      "rwhere",       /* 19 like where + where_use_regexp */
       NULL
    };
 
Index: src/dird/restore.c
===================================================================
--- src/dird/restore.c	(révision 4466)
+++ src/dird/restore.c	(copie de travail)
@@ -50,8 +50,9 @@
 #include "dird.h"
 
 /* Commands sent to File daemon */
-static char restorecmd[]   = "restore replace=%c prelinks=%d where=%s\n";
-static char storaddr[]     = "storage address=%s port=%d ssl=0\n";
+static char restorecmd[]        = "restore replace=%c prelinks=%d where=%s\n";
+static char restorecmdR[] = "restore replace=%c prelinks=%d rwhere=%s\n";
+static char storaddr[]   = "storage address=%s port=%d ssl=0\n";
 
 /* Responses received from File daemon */
 static char OKrestore[]   = "2000 OK restore\n";
@@ -172,7 +173,7 @@
    }
 
    /* Send restore command */
-   char replace, *where;
+   char replace, *where, *cmd;
    char empty = '\0';
 
    if (jcr->replace != 0) {
@@ -189,9 +190,17 @@
    } else {
       where = &empty;                 /* None */
    }
+   
    jcr->prefix_links = jcr->job->PrefixLinks;
+
+   if (jcr->where_use_regexp) {
+      cmd = restorecmdR;
+   } else {
+      cmd = restorecmd;
+   }
+
    bash_spaces(where);
-   bnet_fsend(fd, restorecmd, replace, jcr->prefix_links, where);
+   bnet_fsend(fd, cmd, replace, jcr->prefix_links, where);
    unbash_spaces(where);
 
    if (!response(jcr, fd, OKrestore, "Restore", DISPLAY_ERROR)) {
Index: src/dird/dird_conf.c
===================================================================
--- src/dird/dird_conf.c	(révision 4466)
+++ src/dird/dird_conf.c	(copie de travail)
@@ -52,6 +52,7 @@
 
 #include "bacula.h"
 #include "dird.h"
+#include "lib/breg.h"
 
 /* Define the first and last resource ID record
  * types. Note, these should be unique for each
@@ -268,6 +269,10 @@
    {"run",       store_alist_str, ITEM(res_job.run_cmds), 0, 0, 0},
    /* Root of where to restore files */
    {"where",    store_dir,      ITEM(res_job.RestoreWhere), 0, 0, 0},
+   {"whereuseregexp", store_bool, ITEM(res_job.where_use_regexp), 0, 0, 0},
+   {"stripprefix",    store_str,  ITEM(res_job.strip_prefix), 0, 0, 0},
+   {"addprefix",    store_str,  ITEM(res_job.add_prefix), 0, 0, 0},
+   {"addsuffix",    store_str,  ITEM(res_job.add_suffix), 0, 0, 0},
    /* Where to find bootstrap during restore */
    {"bootstrap",store_dir,      ITEM(res_job.RestoreBootstrap), 0, 0, 0},
    /* Where to write bootstrap file during backup */
@@ -611,6 +616,9 @@
       if (res->res_job.RestoreWhere) {
          sendit(sock, _("  --> Where=%s\n"), NPRT(res->res_job.RestoreWhere));
       }
+      if (res->res_job.where_use_regexp) {
+         sendit(sock, _("  --> RWhere=%u\n"), res->res_job.where_use_regexp);
+      }
       if (res->res_job.RestoreBootstrap) {
          sendit(sock, _("  --> Bootstrap=%s\n"), NPRT(res->res_job.RestoreBootstrap));
       }
@@ -1143,6 +1151,15 @@
       if (res->res_job.RestoreWhere) {
          free(res->res_job.RestoreWhere);
       }
+      if (res->res_job.strip_prefix) {
+         free(res->res_job.strip_prefix);
+      }
+      if (res->res_job.add_prefix) {
+         free(res->res_job.add_prefix);
+      }
+      if (res->res_job.add_suffix) {
+         free(res->res_job.add_suffix);
+      }
       if (res->res_job.RestoreBootstrap) {
          free(res->res_job.RestoreBootstrap);
       }
@@ -1299,6 +1316,19 @@
          res->res_job.jobdefs    = res_all.res_job.jobdefs;
          res->res_job.run_cmds   = res_all.res_job.run_cmds;
          res->res_job.RunScripts = res_all.res_job.RunScripts;
+	 if (res->res_job.strip_prefix ||
+	     res->res_job.add_suffix   ||
+	     res->res_job.add_prefix)
+	 {
+	    if (res->res_job.RestoreWhere) {
+	       free(res->res_job.RestoreWhere);
+	    }
+	    res->res_job.where_use_regexp = true;
+	    res->res_job.RestoreWhere=bregexp_build_where(res->res_job.strip_prefix,
+							  res->res_job.add_prefix,
+							  res->res_job.add_suffix);
+	    /* TODO: test bregexp */
+	 }
          break;
       case R_COUNTER:
          if ((res = (URES *)GetResWithName(R_COUNTER, res_all.res_counter.hdr.name)) == NULL) {
Index: src/dird/ua_run.c
===================================================================
--- src/dird/ua_run.c	(révision 4466)
+++ src/dird/ua_run.c	(copie de travail)
@@ -71,6 +71,7 @@
    int Priority = 0;
    int i, j, opt, files = 0;
    bool kw_ok;
+   bool where_use_regexp = false;
    JOB *job = NULL;
    JOB *verify_job = NULL;
    JOB *previous_job = NULL;
@@ -87,7 +88,7 @@
       "level",                        /* 5 */
       "storage",                      /* 6 */
       "sd",                           /* 7 */
-      "pool",                         /* 8 */
+      "rwhere",                       /* 8 where string as a bregexp */
       "where",                        /* 9 */
       "bootstrap",                    /* 10 */
       "replace",                      /* 11 */
@@ -101,6 +102,7 @@
       "cloned",                       /* 19 cloned */
       "verifylist",                   /* 20 verify output list */
       "migrationjob",                 /* 21 migration job name */
+      "pool",                         /* 22 */
       NULL};
 
 #define YES_POS 14
@@ -188,14 +190,8 @@
                store_name = ua->argv[i];
                kw_ok = true;
                break;
-            case 8: /* pool */
-               if (pool_name) {
-                  ua->send_msg(_("Pool specified twice.\n"));
-                  return 0;
-               }
-               pool_name = ua->argv[i];
-               kw_ok = true;
-               break;
+	    case 8:
+	       where_use_regexp = true;
             case 9: /* where */
                if (where) {
                   ua->send_msg(_("Where specified twice.\n"));
@@ -287,8 +283,15 @@
                previous_job_name = ua->argv[i];
                kw_ok = true;
                break;
+            case 22: /* pool */
+               if (pool_name) {
+                  ua->send_msg(_("Pool specified twice.\n"));
+                  return 0;
+               }
+               pool_name = ua->argv[i];
+               kw_ok = true;
+               break;
 
-
             default:
                break;
             }
@@ -478,6 +481,7 @@
          free(jcr->where);
       }
       jcr->where = bstrdup(where);
+      jcr->where_use_regexp = where_use_regexp;
    }
 
    if (when) {
Index: src/dird/dird_conf.h
===================================================================
--- src/dird/dird_conf.h	(révision 4466)
+++ src/dird/dird_conf.h	(copie de travail)
@@ -356,6 +356,10 @@
    int   Priority;                    /* Job priority */
    int   RestoreJobId;                /* What -- JobId to restore */
    char *RestoreWhere;                /* Where on disk to restore -- directory */
+   char *strip_prefix;                /* remove prefix from filename  */
+   char *add_prefix;                  /* add prefix to filename  */
+   char *add_suffix;                  /* add suffix to filename -- .old */
+   bool  where_use_regexp;            /* true if RestoreWhere is a BREGEXP */
    char *RestoreBootstrap;            /* Bootstrap file */
    alist *RunScripts;                 /* Run {client} program {after|before} Job */
    union {
Index: src/filed/job.c
===================================================================
--- src/filed/job.c	(révision 4467)
+++ src/filed/job.c	(copie de travail)
@@ -36,6 +36,7 @@
 
 #include "bacula.h"
 #include "filed.h"
+#include "lib/breg.h"
 
 #if defined(WIN32_VSS)
 #include "vss.h"
@@ -115,6 +116,7 @@
 static char sessioncmd[]  = "session %127s %ld %ld %ld %ld %ld %ld\n";
 static char restorecmd[]  = "restore replace=%c prelinks=%d where=%s\n";
 static char restorecmd1[] = "restore replace=%c prelinks=%d where=\n";
+static char restorecmdR[] = "restore replace=%c prelinks=%d rwhere=%s\n";
 static char verifycmd[]   = "verify level=%30s";
 static char estimatecmd[] = "estimate listing=%d";
 static char runbefore[]   = "RunBeforeJob %s";
@@ -1586,12 +1588,15 @@
    *where = 0;
 
    if (sscanf(dir->msg, restorecmd, &replace, &prefix_links, where) != 3) {
-      if (sscanf(dir->msg, restorecmd1, &replace, &prefix_links) != 2) {
-         pm_strcpy(jcr->errmsg, dir->msg);
-         Jmsg(jcr, M_FATAL, 0, _("Bad replace command. CMD=%s\n"), jcr->errmsg);
-         return 0;
+      if (sscanf(dir->msg, restorecmdR, &replace, &prefix_links, where) != 3){
+	 if (sscanf(dir->msg, restorecmd1, &replace, &prefix_links) != 2) {
+	    pm_strcpy(jcr->errmsg, dir->msg);
+	    Jmsg(jcr, M_FATAL, 0, _("Bad replace command. CMD=%s\n"), jcr->errmsg);
+	    return 0;
+	 }
+	 *where = 0;
       }
-      *where = 0;
+      jcr->where_use_regexp = true;
    }
    /* Turn / into nothing */
    if (IsPathSeparator(where[0]) && where[1] == '\0') {
@@ -1601,6 +1606,15 @@
    Dmsg2(150, "Got replace %c, where=%s\n", replace, where);
    unbash_spaces(where);
    jcr->where = bstrdup(where);
+
+   if (jcr->where_use_regexp) {
+      jcr->where_bregexp = get_bregexps(jcr->where);
+      if (!jcr->where_bregexp) {
+	 Jmsg(jcr, M_FATAL, 0, _("Bad where regexp. where=%s\n"), jcr->where);
+	 free_pool_memory(where);
+	 return 0;
+      }
+   }
    free_pool_memory(where);
    jcr->replace = replace;
    jcr->prefix_links = prefix_links;
Index: src/jcr.h
===================================================================
--- src/jcr.h	(révision 4466)
+++ src/jcr.h	(copie de travail)
@@ -173,6 +173,8 @@
    MSGS *jcr_msgs;                    /* Copy of message resource -- actually used */
    uint32_t ClientId;                 /* Client associated with Job */
    char *where;                       /* prefix to restore files to */
+   bool where_use_regexp;             /* True if where is a bregexp */
+   alist *where_bregexp;              /* BREGEXP alist for path manipulation */
    int cached_pnl;                    /* cached path length */
    POOLMEM *cached_path;              /* cached path */
    bool prefix_links;                 /* Prefix links with Where path */
Index: src/lib/Makefile.in
===================================================================
--- src/lib/Makefile.in	(révision 4466)
+++ src/lib/Makefile.in	(copie de travail)
@@ -32,7 +32,7 @@
 	  res.c rwlock.c scan.c serial.c sha1.c \
 	  signal.c smartall.c rblist.c tls.c tree.c \
 	  util.c var.c watchdog.c workq.c btimers.c \
-	  address_conf.c pythonlib.c
+	  address_conf.c pythonlib.c breg.c
 
 
 LIBOBJS = attr.o base64.o berrno.o bsys.o bget_msg.o \
@@ -45,7 +45,7 @@
 	  res.o rwlock.o scan.o serial.o sha1.o \
 	  signal.o smartall.o rblist.o tls.o tree.o \
 	  util.o var.o watchdog.o workq.o btimers.o \
-	  address_conf.o pythonlib.o
+	  address_conf.o pythonlib.o breg.o
 
 
 EXTRAOBJS = @OBJLIST@
Index: src/lib/attr.c
===================================================================
--- src/lib/attr.c	(révision 4466)
+++ src/lib/attr.c	(copie de travail)
@@ -35,8 +35,8 @@
 
 #include "bacula.h"
 #include "jcr.h"
+#include "lib/breg.h"
 
-
 ATTR *new_attr()
 {
    ATTR *attr = (ATTR *)malloc(sizeof(ATTR));
@@ -148,9 +148,30 @@
     *   every filename if a prefix is supplied.
     *
     */
+
    if (jcr->where[0] == 0) {
       pm_strcpy(attr->ofname, attr->fname);
       pm_strcpy(attr->olname, attr->lname);
+
+   } else if (jcr->where_bregexp) { 
+      char *ret;
+      apply_bregexps(attr->fname, jcr->where_bregexp, &ret);
+      pm_strcpy(attr->ofname, ret);
+
+      if (attr->type == FT_LNKSAVED || attr->type == FT_LNK) {
+         /* Always add prefix to hard links (FT_LNKSAVED) and
+          *  on user request to soft links
+          */
+
+	 if ((attr->type == FT_LNKSAVED || jcr->prefix_links)) {
+	    apply_bregexps(attr->lname, jcr->where_bregexp, &ret);
+	    pm_strcpy(attr->olname, ret);
+
+	 } else {
+	    pm_strcpy(attr->olname, attr->lname);
+	 }
+      }
+      
    } else {
       const char *fn;
       int wherelen = strlen(jcr->where);
Index: src/lib/jcr.c
===================================================================
--- src/lib/jcr.c	(révision 4466)
+++ src/lib/jcr.c	(copie de travail)
@@ -56,6 +56,9 @@
 /* External variables we reference */
 extern time_t watchdog_time;
 
+/* External referenced functions */
+void free_bregexps(alist *bregexps);
+
 /* Forward referenced functions */
 extern "C" void timeout_handler(int sig);
 static void jcr_timeout_check(watchdog_t *self);
@@ -381,6 +384,11 @@
       free(jcr->where);
       jcr->where = NULL;
    }
+   if (jcr->where_bregexp) {
+      free_bregexps(jcr->where_bregexp);
+      delete jcr->where_bregexp;
+      jcr->where_bregexp = NULL;
+   }
    if (jcr->cached_path) {
       free_pool_memory(jcr->cached_path);
       jcr->cached_path = NULL;
Index: patches/testing/file_relocation.patch
===================================================================
--- patches/testing/file_relocation.patch	(révision 4514)
+++ patches/testing/file_relocation.patch	(copie de travail)
@@ -12,17 +12,18 @@
  /* Imported functions */
  extern void print_bsr(UAContext *ua, RBSR *bsr);
  
-@@ -83,6 +83,9 @@
+@@ -83,6 +83,10 @@
     JCR *jcr = ua->jcr;
     char *escaped_bsr_name = NULL;
     char *escaped_where_name = NULL;
 +   bool where_use_regexp = false;
++   bool have_to_free_where = false;
 +   char *strip_prefix, *add_prefix, *add_suffix;
 +   strip_prefix = add_prefix = add_suffix = NULL;
  
     memset(&rx, 0, sizeof(rx));
     rx.path = get_pool_memory(PM_FNAME);
-@@ -94,6 +97,29 @@
+@@ -94,6 +98,41 @@
     i = find_arg_with_value(ua, "where");
     if (i >= 0) {
        rx.where = ua->argv[i];
@@ -43,8 +44,20 @@
 +      add_suffix = ua->argv[i];
 +   }
 +
++   i = find_arg(ua, "where_use_regexp");
++   if (i >= 0) {
++      where_use_regexp = true;
++   }
++
++   i = find_arg_with_value(ua, "rwhere");
++   if (i >= 0) {
++      where_use_regexp = true;
++      rx.where = ua->argv[i];
++   }
++
 +   if (strip_prefix || add_suffix || add_prefix) {
 +      where_use_regexp = true;
++      have_to_free_where = true;
 +      rx.where = bregexp_build_where(strip_prefix, add_prefix, add_suffix);
 +   }
 +
@@ -52,7 +65,7 @@
        if (!acl_access_ok(ua, Where_ACL, rx.where)) {
           ua->error_msg(_("\"where\" specification not authorized.\n"));
           goto bail_out;
-@@ -195,9 +221,10 @@
+@@ -195,9 +234,10 @@
  
        Mmsg(ua->cmd,
            "run job=\"%s\" client=\"%s\" storage=\"%s\" bootstrap=\"%s\""
@@ -64,28 +77,72 @@
            escaped_where_name ? escaped_where_name : rx.where,
            rx.selected_files, ua->catalog->name());
     } else {
-@@ -216,6 +243,10 @@
+@@ -216,6 +256,10 @@
     if (escaped_where_name != NULL) {
        bfree(escaped_where_name);
     }
 +   
-+   if (where_use_regexp) {
++   if (have_to_free_where) {
 +      free_pool_memory(rx.where);
 +   }
  
     if (find_arg(ua, NT_("yes")) > 0) {
        pm_strcat(ua->cmd, " yes");    /* pass it on to the run command */
-@@ -235,6 +266,10 @@
+@@ -235,6 +279,10 @@
        bfree(escaped_where_name);
     }
  
-+   if (where_use_regexp) {
++   if (have_to_free_where) {
 +      free_pool_memory(rx.where);
 +   }
 +
     free_rx(&rx);
     return 0;
  
+@@ -331,23 +379,28 @@
+ 
+    const char *kw[] = {
+        /* These keywords are handled in a for loop */
+-      "jobid",     /* 0 */
+-      "current",   /* 1 */
+-      "before",    /* 2 */
+-      "file",      /* 3 */
+-      "directory", /* 4 */
+-      "select",    /* 5 */
+-      "pool",      /* 6 */
+-      "all",       /* 7 */
++      "jobid",       /* 0 */
++      "current",     /* 1 */
++      "before",      /* 2 */
++      "file",        /* 3 */
++      "directory",   /* 4 */
++      "select",      /* 5 */
++      "pool",        /* 6 */
++      "all",         /* 7 */
+ 
+       /* The keyword below are handled by individual arg lookups */
+-      "client",    /* 8 */
+-      "storage",   /* 9 */
+-      "fileset",   /* 10 */
+-      "where",     /* 11 */
+-      "yes",       /* 12 */
+-      "bootstrap", /* 13 */
+-      "done",      /* 14 */
++      "client",       /* 8 */
++      "storage",      /* 9 */
++      "fileset",      /* 10 */
++      "where",        /* 11 */
++      "yes",          /* 12 */
++      "bootstrap",    /* 13 */
++      "done",         /* 14 */
++      "strip_prefix", /* 15 */
++      "add_prefix",   /* 16 */
++      "add_suffix",   /* 17 */
++      "where_use_regexp",/* 18 */
++      "rwhere",       /* 19 like where + where_use_regexp */
+       NULL
+    };
+ 
 Index: src/dird/restore.c
 ===================================================================
 --- src/dird/restore.c	(révision 4466)
@@ -134,15 +191,26 @@
 ===================================================================
 --- src/dird/dird_conf.c	(révision 4466)
 +++ src/dird/dird_conf.c	(copie de travail)
-@@ -268,6 +268,7 @@
+@@ -52,6 +52,7 @@
+ 
+ #include "bacula.h"
+ #include "dird.h"
++#include "lib/breg.h"
+ 
+ /* Define the first and last resource ID record
+  * types. Note, these should be unique for each
+@@ -268,6 +269,10 @@
     {"run",       store_alist_str, ITEM(res_job.run_cmds), 0, 0, 0},
     /* Root of where to restore files */
     {"where",    store_dir,      ITEM(res_job.RestoreWhere), 0, 0, 0},
 +   {"whereuseregexp", store_bool, ITEM(res_job.where_use_regexp), 0, 0, 0},
++   {"stripprefix",    store_str,  ITEM(res_job.strip_prefix), 0, 0, 0},
++   {"addprefix",    store_str,  ITEM(res_job.add_prefix), 0, 0, 0},
++   {"addsuffix",    store_str,  ITEM(res_job.add_suffix), 0, 0, 0},
     /* Where to find bootstrap during restore */
     {"bootstrap",store_dir,      ITEM(res_job.RestoreBootstrap), 0, 0, 0},
     /* Where to write bootstrap file during backup */
-@@ -611,6 +612,9 @@
+@@ -611,6 +616,9 @@
        if (res->res_job.RestoreWhere) {
           sendit(sock, _("  --> Where=%s\n"), NPRT(res->res_job.RestoreWhere));
        }
@@ -152,6 +220,42 @@
        if (res->res_job.RestoreBootstrap) {
           sendit(sock, _("  --> Bootstrap=%s\n"), NPRT(res->res_job.RestoreBootstrap));
        }
+@@ -1143,6 +1151,15 @@
+       if (res->res_job.RestoreWhere) {
+          free(res->res_job.RestoreWhere);
+       }
++      if (res->res_job.strip_prefix) {
++         free(res->res_job.strip_prefix);
++      }
++      if (res->res_job.add_prefix) {
++         free(res->res_job.add_prefix);
++      }
++      if (res->res_job.add_suffix) {
++         free(res->res_job.add_suffix);
++      }
+       if (res->res_job.RestoreBootstrap) {
+          free(res->res_job.RestoreBootstrap);
+       }
+@@ -1299,6 +1316,19 @@
+          res->res_job.jobdefs    = res_all.res_job.jobdefs;
+          res->res_job.run_cmds   = res_all.res_job.run_cmds;
+          res->res_job.RunScripts = res_all.res_job.RunScripts;
++	 if (res->res_job.strip_prefix ||
++	     res->res_job.add_suffix   ||
++	     res->res_job.add_prefix)
++	 {
++	    if (res->res_job.RestoreWhere) {
++	       free(res->res_job.RestoreWhere);
++	    }
++	    res->res_job.where_use_regexp = true;
++	    res->res_job.RestoreWhere=bregexp_build_where(res->res_job.strip_prefix,
++							  res->res_job.add_prefix,
++							  res->res_job.add_suffix);
++	    /* TODO: test bregexp */
++	 }
+          break;
+       case R_COUNTER:
+          if ((res = (URES *)GetResWithName(R_COUNTER, res_all.res_counter.hdr.name)) == NULL) {
 Index: src/dird/ua_run.c
 ===================================================================
 --- src/dird/ua_run.c	(révision 4466)
@@ -227,10 +331,13 @@
 ===================================================================
 --- src/dird/dird_conf.h	(révision 4466)
 +++ src/dird/dird_conf.h	(copie de travail)
-@@ -356,6 +356,7 @@
+@@ -356,6 +356,10 @@
     int   Priority;                    /* Job priority */
     int   RestoreJobId;                /* What -- JobId to restore */
     char *RestoreWhere;                /* Where on disk to restore -- directory */
++   char *strip_prefix;                /* remove prefix from filename  */
++   char *add_prefix;                  /* add prefix to filename  */
++   char *add_suffix;                  /* add suffix to filename -- .old */
 +   bool  where_use_regexp;            /* true if RestoreWhere is a BREGEXP */
     char *RestoreBootstrap;            /* Bootstrap file */
     alist *RunScripts;                 /* Run {client} program {after|before} Job */
@@ -398,30 +505,3 @@
     if (jcr->cached_path) {
        free_pool_memory(jcr->cached_path);
        jcr->cached_path = NULL;
-Index: patches/testing/breg.c
-===================================================================
---- patches/testing/breg.c	(révision 4510)
-+++ patches/testing/breg.c	(copie de travail)
-@@ -393,19 +393,19 @@
- 
-    *str_tmp = *ret = '\0';
-    
--   if (*strip_prefix) {
-+   if (strip_prefix) {
-       len += bsnprintf(ret, str_size - len, "!%s!!",
- 		       bregexp_escape_string(str_tmp, strip_prefix, sep));
-    }
- 
--   if (*add_suffix) {
-+   if (add_suffix) {
-       if (len) ret[len++] = ',';
- 
-       len += bsnprintf(ret + len,  str_size - len, "!([^/])$!$1%s!",
- 		       bregexp_escape_string(str_tmp, add_suffix, sep));
-    }
- 
--   if (*add_prefix) {
-+   if (add_prefix) {
-       if (len) ret[len++] = ',';
- 
-       len += bsnprintf(ret + len, str_size - len, "!^!%s!", 
