Index: src/dird/backup.c
===================================================================
--- src/dird/backup.c	(revision 6372)
+++ src/dird/backup.c	(working copy)
@@ -44,6 +44,7 @@
 #include "bacula.h"
 #include "dird.h"
 #include "ua.h"
+#include "findlib/find.h"
 
 /* Commands sent to File daemon */
 static char backupcmd[] = "backup\n";
@@ -97,6 +98,300 @@
 }
 
 /*
+ * We are called here for each record that matches the above
+ *  SQL query -- that is for each file contained in the Catalog
+ *  that was not marked earlier. This means that the file in
+ *  question is a missing file (in the Catalog but not on Disk).
+ */
+static int missing_handler(void *ctx, int num_fields, char **row)
+{
+   JCR *jcr = (JCR *)ctx;
+
+   if (job_canceled(jcr)) {
+      return 1;
+   }
+
+   /* TODO: return the list to the FD */
+   Qmsg(jcr, M_INFO, 0, "      %s%s\n", row[0]?row[0]:"", row[1]?row[1]:"");
+   return 0;
+}
+
+/*
+ * Accurate backup mode
+ * 1. Receive the list of all files including those backed up to the Dir
+ * 2. Dir computes files and deleted files.
+ * 3. Dir sends list of additional files (new files) to backup, and list of files
+ *    deleted.
+ *
+ * Cleanup attributes (don't use atime, inode etc..)
+ * Need to insert file and attributes to temp table
+ * Batch compare files and attributes 
+ *
+ *
+ */
+bool accurate_compute_files(JCR *jcr)
+{
+   BSOCK   *fd;
+   int n, len;
+   FILE_DBR fdbr;
+   struct stat statf;                 /* file stat */
+   struct stat statc;                 /* catalog stat */
+   int stat = JS_Terminated;
+   char buf[MAXSTRING];
+   char ed1[50], ed2[50];
+   POOLMEM *fname = get_pool_memory(PM_MESSAGE);
+   int do_Digest = CRYPTO_DIGEST_NONE;
+   int32_t file_index = 0;
+   JobId_t JobId=0;		/* TODO: compute the job key in new table */
+   JobId_t backupid=0;
+
+   memset(&fdbr, 0, sizeof(FILE_DBR));
+   fd = jcr->file_bsock;
+   fdbr.JobId = JobId;		
+   jcr->FileIndex = 0;
+
+   if (jcr->accurate == false || jcr->JobLevel == L_FULL) {
+      return true;
+   }
+
+   backupid = db_find_backupid(jcr, jcr->db, &jcr->jr);
+   if (!backupid) {
+      Jmsg(jcr, M_ERROR, 0, _("Can't use Accurate mode ERR=Can't find BackupId\n"));
+      return false;
+   }
+
+   Dmsg0(20, "bdird: waiting to receive file attributes\n");
+   /*
+    * Get Attributes and Signature from File daemon
+    * We expect:
+    *   FileIndex
+    *   Stream
+    *   Options or Digest (MD5/SHA1)
+    *   Filename
+    *   Attributes
+    *   Link name  ???
+    */
+   while ((n=bget_dirmsg(fd)) >= 0 && !job_canceled(jcr)) {
+      int stream;
+      char *attr, *p, *fn;
+      char Opts_Digest[MAXSTRING];        /* Verify Opts or MD5/SHA1 digest */
+
+      if (job_canceled(jcr)) {
+         return false;
+      }
+      fname = check_pool_memory_size(fname, fd->msglen);
+      jcr->fname = check_pool_memory_size(jcr->fname, fd->msglen);
+      Dmsg1(20, "Atts+Digest=%s\n", fd->msg);
+      if ((len = sscanf(fd->msg, "%ld %d %100s", &file_index, &stream,
+            fname)) != 3) {
+         Jmsg3(jcr, M_FATAL, 0, _("bird<filed: bad attributes, expected 3 fields got %d\n"
+" mslen=%d msg=%s\n"), len, fd->msglen, fd->msg);
+         return false;
+      }
+      /*
+       * We read the Options or Signature into fname
+       *  to prevent overrun, now copy it to proper location.
+       */
+      bstrncpy(Opts_Digest, fname, sizeof(Opts_Digest));
+      p = fd->msg;
+      skip_nonspaces(&p);             /* skip FileIndex */
+      skip_spaces(&p);
+      skip_nonspaces(&p);             /* skip Stream */
+      skip_spaces(&p);
+      skip_nonspaces(&p);             /* skip Opts_Digest */
+      p++;                            /* skip space */
+      fn = fname;
+      while (*p != 0) {
+         *fn++ = *p++;                /* copy filename */
+      }
+      *fn = *p++;                     /* term filename and point to attribs */
+      attr = p;
+      /*
+       * Got attributes stream, decode it
+       */
+      if (stream == STREAM_UNIX_ATTRIBUTES || stream == STREAM_UNIX_ATTRIBUTES_EX) {
+         int32_t LinkFIf, LinkFIc;
+         Dmsg2(400, "file_index=%d attr=%s\n", file_index, attr);
+         jcr->JobFiles++;
+         jcr->FileIndex = file_index;    /* remember attribute file_index */
+         decode_stat(attr, &statf, &LinkFIf);  /* decode file stat packet */
+         do_Digest = CRYPTO_DIGEST_NONE;
+         pm_strcpy(jcr->fname, fname);  /* move filename into JCR */
+
+         Dmsg3(040, "dird<filed: stream=%d %s %s\n", stream, jcr->fname, attr);
+
+         /*
+          * Find equivalent record in the database
+          */
+         fdbr.FileId = 0;
+         if (!db_accurate_get_file_attributes_record(jcr, jcr->db, jcr->fname, backupid, &fdbr)) {
+            Jmsg(jcr, M_INFO, 0, _("New file: %s\n"), jcr->fname);
+            Dmsg1(020, _("File not in catalog: %s\n"), jcr->fname);
+            continue;
+         } else {
+            /*
+             * mark file record as visited by stuffing the
+             * current JobId, which is unique, into the MarkId field.
+             */
+            db_mark_file_record(jcr, jcr->db, fdbr.FileId, jcr->JobId);
+         }
+
+         Dmsg3(400, "Found %s in catalog. inx=%d Opts=%s\n", jcr->fname,
+            file_index, Opts_Digest);
+         decode_stat(fdbr.LStat, &statc, &LinkFIc); /* decode catalog stat */
+
+	 // TODO: for each JS_Differences, send it to FD for backup
+         /*
+          * Loop over options supplied by user and verify the
+          * fields he requests.
+          */
+         for (p=Opts_Digest; *p; p++) {
+            char ed1[30], ed2[30];
+            switch (*p) {
+            case 'i':                /* compare INODEs */
+               if (statc.st_ino != statf.st_ino) {
+                  Jmsg(jcr, M_INFO, 0, _("      st_ino   differ. Cat: %s File: %s\n"),
+                     edit_uint64((uint64_t)statc.st_ino, ed1),
+                     edit_uint64((uint64_t)statf.st_ino, ed2));
+                  stat = JS_Differences;
+               }
+               break;
+            case 'p':                /* permissions bits */
+               if (statc.st_mode != statf.st_mode) {
+                  Jmsg(jcr, M_INFO, 0, _("      st_mode  differ. Cat: %x File: %x\n"),
+                     (uint32_t)statc.st_mode, (uint32_t)statf.st_mode);
+                  stat = JS_Differences;
+               }
+               break;
+            case 'n':                /* number of links */
+               if (statc.st_nlink != statf.st_nlink) {
+                  Jmsg(jcr, M_INFO, 0, _("      st_nlink differ. Cat: %d File: %d\n"),
+                     (uint32_t)statc.st_nlink, (uint32_t)statf.st_nlink);
+                  stat = JS_Differences;
+               }
+               break;
+            case 'u':                /* user id */
+               if (statc.st_uid != statf.st_uid) {
+                  Jmsg(jcr, M_INFO, 0, _("      st_uid   differ. Cat: %u File: %u\n"),
+                     (uint32_t)statc.st_uid, (uint32_t)statf.st_uid);
+                  stat = JS_Differences;
+               }
+               break;
+            case 'g':                /* group id */
+               if (statc.st_gid != statf.st_gid) {
+                  Jmsg(jcr, M_INFO, 0, _("      st_gid   differ. Cat: %u File: %u\n"),
+                     (uint32_t)statc.st_gid, (uint32_t)statf.st_gid);
+                  stat = JS_Differences;
+               }
+               break;
+            case 's':                /* size */
+               if (statc.st_size != statf.st_size) {
+                  Jmsg(jcr, M_INFO, 0, _("      st_size  differ. Cat: %s File: %s\n"),
+                     edit_uint64((uint64_t)statc.st_size, ed1),
+                     edit_uint64((uint64_t)statf.st_size, ed2));
+                  stat = JS_Differences;
+               }
+               break;
+            case 'a':                /* access time */
+               if (statc.st_atime != statf.st_atime) {
+                  Jmsg(jcr, M_INFO, 0, _("      st_atime differs\n"));
+                  stat = JS_Differences;
+               }
+               break;
+            case 'm':
+               if (statc.st_mtime != statf.st_mtime) {
+                  Jmsg(jcr, M_INFO, 0, _("      st_mtime differs\n"));
+                  stat = JS_Differences;
+               }
+               break;
+            case 'c':                /* ctime */
+               if (statc.st_ctime != statf.st_ctime) {
+                  Jmsg(jcr, M_INFO, 0, _("      st_ctime differs\n"));
+                  stat = JS_Differences;
+               }
+               break;
+            case 'd':                /* file size decrease */
+               if (statc.st_size > statf.st_size) {
+                  Jmsg(jcr, M_INFO, 0, _("      st_size  decrease. Cat: %s File: %s\n"),
+                     edit_uint64((uint64_t)statc.st_size, ed1),
+                     edit_uint64((uint64_t)statf.st_size, ed2));
+                  stat = JS_Differences;
+               }
+               break;
+            case '5':                /* compare MD5 */
+               Dmsg1(500, "set Do_MD5 for %s\n", jcr->fname);
+               do_Digest = CRYPTO_DIGEST_MD5;
+               break;
+            case '1':                 /* compare SHA1 */
+               do_Digest = CRYPTO_DIGEST_SHA1;
+               break;
+            case ':':
+            case 'V':
+            default:
+               break;
+            }
+         }
+      /*
+       * Got Digest Signature from Storage daemon
+       *  It came across in the Opts_Digest field.
+       */
+      } else if (crypto_digest_stream_type(stream) != CRYPTO_DIGEST_NONE) {
+         Dmsg2(400, "stream=Digest inx=%d Digest=%s\n", file_index, Opts_Digest);
+         /*
+          * When ever we get a digest it MUST have been
+          * preceded by an attributes record, which sets attr_file_index
+          */
+         if (jcr->FileIndex != (uint32_t)file_index) {
+            Jmsg2(jcr, M_FATAL, 0, _("MD5/SHA1 index %d not same as attributes %d\n"),
+               file_index, jcr->FileIndex);
+            return false;
+         }
+         if (do_Digest != CRYPTO_DIGEST_NONE) {
+            db_escape_string(jcr, jcr->db, buf, Opts_Digest, strlen(Opts_Digest));
+            if (strcmp(buf, fdbr.Digest) != 0) {
+               if (debug_level >= 10) {
+                  Jmsg(jcr, M_INFO, 0, _("      %d not same. File=%s Cat=%s\n"),
+                       stream, buf, fdbr.Digest);
+               } else {
+                  Jmsg(jcr, M_INFO, 0, _("      %d differs.\n"),
+                       stream);
+               }
+               stat = JS_Differences;
+            }
+            do_Digest = CRYPTO_DIGEST_NONE;
+         }
+      }
+//      jcr->JobFiles = file_index;
+   }
+   if (is_bnet_error(fd)) {
+      berrno be;
+      Jmsg2(jcr, M_FATAL, 0, _("bdird<filed: bad attributes from filed n=%d : %s\n"),
+                        n, be.bstrerror());
+      return false;
+   }
+
+   /* Now find all the files that are missing -- i.e. all files in
+    *  the database where the MarkId != current JobId
+    */
+
+   bsnprintf(buf, sizeof(buf),
+      "SELECT Path.Path,Filename.Name "
+        "FROM CurrentBackup "
+             "JOIN File USING (FileId) "
+             "JOIN Path USING (PathId) "
+             "JOIN Filename USING (FilenameId) "
+      "WHERE CurrentBackup.BackupId=%s "
+        "AND File.MarkId!=%d ",
+	     edit_uint64(backupid, ed1), edit_uint64(jcr->JobId, ed2));
+   /* missing_handler is called for each file found */
+   db_sql_query(jcr->db, buf, missing_handler, (void *)jcr);
+
+   free_pool_memory(fname);
+
+   return true;
+}
+
+/*
  * Do a backup of the specified FileSet
  *
  *  Returns:  false on failure
@@ -231,6 +526,13 @@
       goto bail_out;
    }
 
+   /*
+    * If backup is in accurate mode, FD will send the list of
+    * all files. We have to store it, and compute witch files
+    * have been deleted and witch files have to be backuped.
+    */
+   accurate_compute_files(jcr);
+
    /* Pickup Job termination data */
    stat = wait_for_job_termination(jcr);
    db_write_batch_file_records(jcr);    /* used by bulk batch file insert */
Index: src/dird/inc_conf.c
===================================================================
--- src/dird/inc_conf.c	(revision 6372)
+++ src/dird/inc_conf.c	(working copy)
@@ -94,6 +94,7 @@
  * Items that are valid in an Options resource
  */
 static RES_ITEM options_items[] = {
+   {"accurate",        store_opts,    {0},     0, 0, 0},
    {"compression",     store_opts,    {0},     0, 0, 0},
    {"signature",       store_opts,    {0},     0, 0, 0},
    {"verify",          store_opts,    {0},     0, 0, 0},
@@ -153,7 +154,8 @@
    INC_KW_NOATIME,
    INC_KW_ENHANCEDWILD,
    INC_KW_CHKCHANGES,
-   INC_KW_STRIPPATH
+   INC_KW_STRIPPATH,
+   INC_KW_ACCURATE
 };
 
 /*
@@ -163,6 +165,7 @@
  *   options given above.
  */
 static struct s_kw FS_option_kw[] = {
+   {"accurate",    INC_KW_ACCURATE},
    {"compression", INC_KW_COMPRESSION},
    {"signature",   INC_KW_DIGEST},
    {"encryption",  INC_KW_ENCRYPTION},
@@ -251,6 +254,8 @@
    {"no",       INC_KW_ENHANCEDWILD,  "0"},
    {"yes",      INC_KW_CHKCHANGES,    "c"},
    {"no",       INC_KW_CHKCHANGES,    "0"},
+   {"yes",      INC_KW_ACCURATE,      "C"},
+   {"no",       INC_KW_ACCURATE,      "0"},
    {NULL,       0,                      0}
 };
 
Index: src/dird/dird_conf.c
===================================================================
--- src/dird/dird_conf.c	(revision 6372)
+++ src/dird/dird_conf.c	(working copy)
@@ -319,6 +319,7 @@
    {"selectionpattern", store_str, ITEM(res_job.selection_pattern), 0, 0, 0},
    {"runscript", store_runscript, ITEM(res_job.RunScripts), 0, ITEM_NO_EQUALS, 0},
    {"selectiontype", store_migtype, ITEM(res_job.selection_type), 0, 0, 0},
+   {"accuratebackup", store_bool, ITEM(res_job.accurate), 0,0,0},
    {NULL, NULL, {0}, 0, 0, 0}
 };
 
@@ -618,6 +619,9 @@
       if (res->res_job.spool_size) {
          sendit(sock, _("     SpoolSize=%s\n"),        edit_uint64(res->res_job.spool_size, ed1));
       }
+      if (res->res_job.JobType == JT_BACKUP) {
+	 sendit(sock, _("     Accurate=%d\n"), res->res_job.accurate);
+      }
       if (res->res_job.JobType == JT_MIGRATE) {
          sendit(sock, _("     SelectionType=%d\n"), res->res_job.selection_type);
       }
Index: src/dird/dird_conf.h
===================================================================
--- src/dird/dird_conf.h	(revision 6372)
+++ src/dird/dird_conf.h	(working copy)
@@ -400,6 +400,7 @@
    bool write_part_after_job;         /* Set to write part after job in SD */
    bool enabled;                      /* Set if job enabled */
    bool OptimizeJobScheduling;        /* Set if we should optimize Job scheduling */
+   bool accurate;                     /* Set if it is an accurate backup job */
    
    MSGS      *messages;               /* How and where to send messages */
    SCHED     *schedule;               /* When -- Automatic schedule */
Index: src/filed/backup.c
===================================================================
--- src/filed/backup.c	(revision 6372)
+++ src/filed/backup.c	(working copy)
@@ -50,6 +50,81 @@
 static bool crypto_session_send(JCR *jcr, BSOCK *sd);
 
 /*
+ * Called by save_file when accept/discard file for backup
+ * TODO: we could add MD5/SHAX digest, but we have to compute it
+ * for all files.
+ */
+static bool accurate_add_file(JCR *jcr, FF_PKT *ff_pkt, char *stats)
+{
+   char *a=stats;
+   char attribs[MAXSTRING];
+   uint32_t file_index=jcr->JobFiles;
+   BSOCK *dir = jcr->dir_bsock;
+   int stat;
+
+   if (jcr->accurate == false || jcr->JobLevel == L_FULL) {
+      return true;
+   }
+
+   if (!stats) {
+      file_index=0;
+      encode_stat(attribs, ff_pkt, 0);
+      a = attribs;
+   }
+
+   if (ff_pkt->type == FT_LNK || ff_pkt->type == FT_LNKSAVED) {
+      stat = dir->fsend("%d %d %s %s%c%s%c%s%c", file_index,
+            STREAM_UNIX_ATTRIBUTES, ff_pkt->VerifyOpts, ff_pkt->fname,
+            0, a, 0, ff_pkt->link, 0);
+   } else if (ff_pkt->type == FT_DIREND || ff_pkt->type == FT_REPARSE) {
+         /* Here link is the canonical filename (i.e. with trailing slash) */
+      stat = dir->fsend("%d %d %s %s%c%s%c%c", file_index,
+               STREAM_UNIX_ATTRIBUTES, ff_pkt->VerifyOpts, ff_pkt->link,
+               0, a, 0, 0);
+   } else {
+      stat = dir->fsend("%d %d %s %s%c%s%c%c", file_index,
+            STREAM_UNIX_ATTRIBUTES, ff_pkt->VerifyOpts, ff_pkt->fname,
+            0, a, 0, 0);
+   }
+
+   if (!stat) {
+      Jmsg(jcr, M_FATAL, 0, _("Network error in send to Director: ERR=%s\n"), bnet_strerror(dir));
+      return 0;
+   }
+
+   return true;
+}
+
+/* build a fileset with new files from director */
+static bool accurate_get_new_and_deleted_file_list(JCR *jcr)
+{   
+   if (jcr->accurate == false || job_canceled(jcr)) {
+      return true;
+   }
+   return true;
+}
+
+/* send deleted file list to stored */
+static bool accurate_send_deleted_list(JCR *jcr)
+{
+   if (jcr->accurate == false || job_canceled(jcr)) {
+      return true;
+   }
+   return true;
+}
+
+static bool accurate_send_file_list(JCR *jcr)
+{
+   if (jcr->accurate == false || job_canceled(jcr)) {
+      return true;
+   }
+   Dmsg0(1, "Sending BNET_EOD\n");
+   jcr->dir_bsock->signal(BNET_EOD);            /* end of sending data */
+   return true;
+}
+
+
+/*
  * Find all the requested files and send them
  * to the Storage daemon.
  *
@@ -66,6 +141,7 @@
    BSOCK *sd;
    bool ok = true;
    // TODO landonf: Allow user to specify encryption algorithm
+   jcr->accurate=true;		/* TODO: remove that */
 
    sd = jcr->store_bsock;
 
@@ -135,6 +211,20 @@
       set_jcr_job_status(jcr, JS_ErrorTerminated);
    }
 
+   /* start accurate stuffs */
+   if (jcr->accurate) {
+      /* TODO: test job_canceled() */
+      accurate_send_file_list(jcr);                 /* send all files to DIR */
+      accurate_get_new_and_deleted_file_list(jcr);  /* get a new incr fileset from DIR */
+//      set_find_options((FF_PKT *)jcr->ff, 0, 0);            /* we backup all that director wants */
+//      if (!find_files(jcr, (FF_PKT *)jcr->ff, save_file, (void *)jcr)) {
+//	 ok = false;                     /* error */
+//	 set_jcr_job_status(jcr, JS_ErrorTerminated);
+//      }
+//      accurate_send_file_list(jcr);                 /* send all new files to DIR */
+      accurate_send_deleted_list(jcr);              /* send deleted list to SD  */
+   }
+
    free_pool_memory(jcr->acl_text);
 
    stop_heartbeat_monitor(jcr);
@@ -355,9 +445,11 @@
    case FT_DIRNOCHG:
    case FT_NOCHG:
       Jmsg(jcr, M_SKIPPED, 1, _("     Unchanged file skipped: %s\n"), ff_pkt->fname);
+      accurate_add_file(jcr, ff_pkt, NULL); /* list skipped files */
       return 1;
    case FT_ISARCH:
       Jmsg(jcr, M_NOTSAVED, 0, _("     Archive file not saved: %s\n"), ff_pkt->fname);
+      accurate_add_file(jcr, ff_pkt, NULL); /* list skipped files */
       return 1;
    case FT_NOOPEN: {
       berrno be;
@@ -1111,6 +1203,9 @@
    }
    unstrip_path(ff_pkt);
 
+   /* list backuped files */
+   accurate_add_file(jcr, ff_pkt, attribs);
+
    Dmsg2(300, ">stored: attr len=%d: %s\n", sd->msglen, sd->msg);
    if (!stat) {
       Jmsg1(jcr, M_FATAL, 0, _("Network send error to SD. ERR=%s\n"),
Index: src/filed/job.c
===================================================================
--- src/filed/job.c	(revision 6372)
+++ src/filed/job.c	(working copy)
@@ -1087,6 +1087,9 @@
       case 'c':
          fo->flags |= FO_CHKCHANGES;
          break;
+      case 'C':
+         fo->flags |= FO_ACCURATE;
+         break;
       default:
          Emsg1(M_ERROR, 0, _("Unknown include/exclude option: %c\n"), *p);
          break;
Index: src/cats/make_postgresql_tables.in
===================================================================
--- src/cats/make_postgresql_tables.in	(revision 6372)
+++ src/cats/make_postgresql_tables.in	(working copy)
@@ -43,6 +43,58 @@
 CREATE INDEX file_jobid_idx on file (jobid);
 CREATE INDEX file_fp_idx on file (filenameid, pathid);
 
+CREATE TABLE CurrentBackupId
+(
+     BackupId          serial     not null,
+     ClientId          integer    not null,
+     JobName           text       not null,
+     FileSetId         integer    not null,
+     primary key (BackupId)
+);
+
+-- Serait bien de prendre la meme table pour
+-- les File et le CurrentBackup...
+-- Mais y'a des problemes pour les prunes
+
+CREATE TABLE CurrentBackup
+(
+     FileId           integer    not null,
+     BackupId         integer    not null,
+     FullMark         char(1)    default 0,
+     primary key (FileId)
+);
+
+CREATE INDEX currentbackup_fileid on CurrentBackup (BackupId);
+
+-- CREATE TEMPORARY TABLE batch (fileindex int,
+--                               jobid int,
+--                               path varchar,
+--                               name varchar,
+--                               lstat varchar,
+--                               md5 varchar);
+-- 
+-- -- On batch insert dans la table temporaire
+
+-- il faut trouver les fichiers manquant
+-- INSERT des nouveaux, UPDATE des anciens, SELECT pour trouver les deletes
+
+
+-- il faut trouver les fichiers modifies
+-- Le champs LStat n'est plus le meme
+-- SELECT * 
+--   FROM CurrentBackup, 
+--        batch JOIN Path USING (Path) JOIN Filename USING (Name)
+--  WHERE Path.PathId = CurrentBackup.PathId
+--    AND Filename.FilenameId = CurrentBackup.FilenameId
+--    AND CurrentBackup.LStat != batch.LStat
+-- 
+-- il faut mettre a jour la liste des fichiers
+
+
+
+
+
+
 --
 -- Possibly add one or more of the following indexes
 --  if your Verifies are too slow.
Index: src/cats/protos.h
===================================================================
--- src/cats/protos.h	(revision 6372)
+++ src/cats/protos.h	(working copy)
@@ -82,10 +82,12 @@
 /* sql_find.c */
 bool db_find_job_start_time(JCR *jcr, B_DB *mdb, JOB_DBR *jr, POOLMEM **stime);
 bool db_find_last_jobid(JCR *jcr, B_DB *mdb, const char *Name, JOB_DBR *jr);
+JobId_t db_find_backupid(JCR *jcr, B_DB *mdb, JOB_DBR *jr);
 int db_find_next_volume(JCR *jcr, B_DB *mdb, int index, bool InChanger, MEDIA_DBR *mr);
 bool db_find_failed_job_since(JCR *jcr, B_DB *mdb, JOB_DBR *jr, POOLMEM *stime, int &JobLevel);
 
 /* sql_get.c */
+int db_accurate_get_file_attributes_record(JCR *jcr, B_DB *mdb, char *fname, JobId_t backupid, FILE_DBR *fdbr);
 bool db_get_pool_record(JCR *jcr, B_DB *db, POOL_DBR *pdbr);
 int db_get_client_record(JCR *jcr, B_DB *mdb, CLIENT_DBR *cr);
 bool db_get_job_record(JCR *jcr, B_DB *mdb, JOB_DBR *jr);
Index: src/cats/sql_find.c
===================================================================
--- src/cats/sql_find.c	(revision 6372)
+++ src/cats/sql_find.c	(working copy)
@@ -190,7 +190,55 @@
    return true;
 }
 
+/*
+ * Find BackupId of last job that ran.  E.g. for
+ *
+ * Returns: Last backuip
+ *
+ */
+JobId_t
+db_find_backupid(JCR *jcr, B_DB *mdb, JOB_DBR *jr)
+{
+   SQL_ROW row;
+   char ed1[50],ed2[50];
+   JobId_t backupid=0;
 
+   /* Find backupid */
+   db_lock(mdb);
+   Dmsg2(100, "JobLevel=%d JobType=%d\n", jcr->JobLevel, jcr->JobType);
+   Mmsg(mdb->cmd,
+"SELECT BackupId FROM CurrentBackupId WHERE JobName='%s' AND "
+"ClientId=%s AND FileSetId=%s ORDER BY BackupId DESC LIMIT 1",
+	jr->Name, 
+	edit_int64(jr->ClientId, ed1),
+	edit_int64(jr->FileSetId, ed2));
+
+   Dmsg1(100, "Query: %s\n", mdb->cmd);
+   if (!QUERY_DB(jcr, mdb, mdb->cmd)) {
+      db_unlock(mdb);
+      return 0;
+   }
+   if ((row = sql_fetch_row(mdb)) == NULL) {
+      Mmsg1(&mdb->errmsg, _("No Job found for: %s.\n"), mdb->cmd);
+      sql_free_result(mdb);
+      db_unlock(mdb);
+      return 0;
+   }
+
+   backupid = str_to_int64(row[0]);
+   sql_free_result(mdb);
+
+   if (backupid <= 0) {
+      Mmsg1(&mdb->errmsg, _("No Job found for: %s\n"), mdb->cmd);
+      db_unlock(mdb);
+      return 0;
+   }
+
+   db_unlock(mdb);
+   return backupid;
+}
+
+
 /*
  * Find JobId of last job that ran.  E.g. for
  *   VERIFY_CATALOG we want the JobId of the last INIT.
Index: src/cats/sql_create.c
===================================================================
--- src/cats/sql_create.c	(revision 6372)
+++ src/cats/sql_create.c	(working copy)
@@ -829,6 +829,14 @@
    return true;
 }
 
+bool db_accurate_insert(JCR *jcr, B_DB *mdb, bool saved, const char *fname, struct stat *stat)
+{
+   int len;
+   split_path_and_file(jcr, mdb, fname);
+   /* make like in Verify code */
+   return true;
+} 
+
 /*
  * Create File record in B_DB
  *
Index: src/cats/sql_get.c
===================================================================
--- src/cats/sql_get.c	(revision 6372)
+++ src/cats/sql_get.c	(working copy)
@@ -66,6 +66,8 @@
  *
  *  Returns: 0 on failure
  *           1 on success with the File record in FILE_DBR
+ *
+ * TODO: optimize this with only one query
  */
 int db_get_file_attributes_record(JCR *jcr, B_DB *mdb, char *fname, JOB_DBR *jr, FILE_DBR *fdbr)
 {
@@ -86,7 +88,70 @@
    return stat;
 }
 
+/*
+ * Given a full filename (with path), look up the File record
+ * (with attributes) in the database.
+ *
+ *  Returns: 0 on failure
+ *           1 on success with the File record in FILE_DBR
+ */
+int db_accurate_get_file_attributes_record(JCR *jcr, B_DB *mdb, char *fname, JobId_t backupid, FILE_DBR *fdbr)
+{
+   int stat;
+   char ed1[50];
+   SQL_ROW row;
 
+   db_lock(mdb);
+   split_path_and_file(jcr, mdb, fname);
+
+   mdb->esc_name = check_pool_memory_size(mdb->esc_name, 2*mdb->fnl+2);
+   db_escape_string(jcr, mdb, mdb->esc_name, mdb->fname, mdb->fnl);
+
+   mdb->esc_path = check_pool_memory_size(mdb->esc_path, 2*mdb->pnl+2);
+   db_escape_string(jcr, mdb, mdb->esc_path, mdb->path, mdb->pnl);
+
+   Mmsg(mdb->cmd,
+"SELECT FileId, LStat, MD5, FilenameId, PathId, FileIndex, MarkId, JobId "
+  "FROM File JOIN CurrentBackup USING (FileId) "
+            "JOIN Filename USING (FilenameId) "
+            "JOIN Path     USING (PathId) "
+ "WHERE Path.Path='%s' "
+   "AND Filename.Name='%s' "
+   "AND BackupId=%s ",
+	mdb->esc_path,
+	mdb->esc_name,
+	edit_int64(backupid, ed1));
+
+   if (QUERY_DB(jcr, mdb, mdb->cmd)) {
+      char ed1[30];
+      mdb->num_rows = sql_num_rows(mdb);
+      if (mdb->num_rows == 1) {
+         if ((row = sql_fetch_row(mdb)) == NULL) {
+            Mmsg1(mdb->errmsg, _("error fetching row: %s\n"), sql_strerror(mdb));
+         } else {
+	    fdbr->FileId     = str_to_int64(row[0]);
+            bstrncpy(fdbr->LStat, row[1], sizeof(fdbr->LStat));
+            bstrncpy(fdbr->Digest, row[2], sizeof(fdbr->Digest));
+	    fdbr->FilenameId = str_to_int64(row[3]);
+	    fdbr->PathId     = str_to_int64(row[4]);
+	    fdbr->FileIndex  = str_to_int64(row[5]);
+	    fdbr->MarkId     = str_to_int64(row[6]);
+	    fdbr->JobId      = str_to_int64(row[7]);
+	 }
+      } else {
+	 Mmsg1(mdb->errmsg, _("Get DB File record %s failed\n"),fname);
+         Jmsg(jcr, M_WARNING, 0, "%s", mdb->errmsg);
+      }
+      sql_free_result(mdb);
+   } else {
+      Mmsg(mdb->errmsg, _("File record: %s not found in Catalog for BackupId=%s.\n"), fname, ed1);
+   }
+
+   db_unlock(mdb);
+
+   return stat;
+}
+
 /*
  * Get a File record
  * Returns: 0 on failure
Index: src/jcr.h
===================================================================
--- src/jcr.h	(revision 6372)
+++ src/jcr.h	(working copy)
@@ -208,6 +208,7 @@
    B_DB *db_batch;                    /* database pointer for batch insert */
    ATTR_DBR *ar;                      /* DB attribute record */
    guid_list *id_list;                /* User/group id to name list */
+   bool accurate;                     /* true if job is accurate */
 
    void *plugin_ctx_list;             /* list of contexts for plugins */
    void *plugin_ctx;                  /* current plugin context */
Index: src/findlib/find.h
===================================================================
--- src/findlib/find.h	(revision 6372)
+++ src/findlib/find.h	(working copy)
@@ -108,6 +108,7 @@
 #define FO_ENHANCEDWILD (1<<23)       /* Enhanced wild card processing */
 #define FO_CHKCHANGES   (1<<24)       /* Check if file have been modified during backup */
 #define FO_STRIPPATH    (1<<25)       /* Check for stripping path */
+#define FO_ACCURATE     (1<<26)       /* Accurate mode */
 
 struct s_included_file {
    struct s_included_file *next;
