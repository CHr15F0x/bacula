Index: src/dird/fd_cmds.c
===================================================================
--- src/dird/fd_cmds.c	(révision 6372)
+++ src/dird/fd_cmds.c	(copie de travail)
@@ -50,7 +50,7 @@
 static char filesetcmd[]  = "fileset%s\n"; /* set full fileset */
 static char jobcmd[]      = "JobId=%s Job=%s SDid=%u SDtime=%u Authorization=%s\n";
 /* Note, mtime_only is not used here -- implemented as file option */
-static char levelcmd[]    = "level = %s%s mtime_only=%d\n";
+static char levelcmd[]    = "level = %s%s%s mtime_only=%d\n";
 static char runscript[]   = "Run OnSuccess=%u OnFailure=%u AbortOnError=%u When=%u Command=%s\n";
 static char runbeforenow[]= "RunBeforeNow\n";
 
@@ -217,7 +217,7 @@
    char ed1[50];
 
    stime = str_to_utime(jcr->stime);
-   fd->fsend(levelcmd, NT_("since_utime "), edit_uint64(stime, ed1), 0);
+   fd->fsend(levelcmd, "", NT_("since_utime "), edit_uint64(stime, ed1), 0);
    while (bget_dirmsg(fd) >= 0) {  /* allow him to poll us to sync clocks */
       Jmsg(jcr, M_INFO, 0, "%s\n", fd->msg);
    }
@@ -231,24 +231,25 @@
 bool send_level_command(JCR *jcr)
 {
    BSOCK   *fd = jcr->file_bsock;
+   const char *accurate=jcr->job->accurate?"accurate_":"";
    /*
     * Send Level command to File daemon
     */
    switch (jcr->JobLevel) {
    case L_BASE:
-      fd->fsend(levelcmd, "base", " ", 0);
+      fd->fsend(levelcmd, "", "base", " ", 0);
       break;
    /* L_NONE is the console, sending something off to the FD */
    case L_NONE:
    case L_FULL:
-      fd->fsend(levelcmd, "full", " ", 0);
+      fd->fsend(levelcmd, "", "full", " ", 0);
       break;
    case L_DIFFERENTIAL:
-      fd->fsend(levelcmd, "differential", " ", 0);
+      fd->fsend(levelcmd, accurate, "differential", " ", 0);
       send_since_time(jcr);
       break;
    case L_INCREMENTAL:
-      fd->fsend(levelcmd, "incremental", " ", 0);
+      fd->fsend(levelcmd, accurate, "incremental", " ", 0);
       send_since_time(jcr);
       break;
    case L_SINCE:
Index: src/dird/backup.c
===================================================================
--- src/dird/backup.c	(révision 6372)
+++ src/dird/backup.c	(copie de travail)
@@ -44,6 +44,7 @@
 #include "bacula.h"
 #include "dird.h"
 #include "ua.h"
+#include "findlib/find.h"
 
 /* Commands sent to File daemon */
 static char backupcmd[] = "backup\n";
@@ -97,6 +98,411 @@
 }
 
 /*
+ * We are called here for each record that matches the above
+ *  SQL query -- that is for each file contained in the Catalog
+ *  that was not marked earlier. This means that the file in
+ *  question is a missing file (in the Catalog but not on Disk).
+ */
+static int missing_handler(void *ctx, int num_fields, char **row)
+{
+   JCR *jcr = (JCR *)ctx;
+
+   if (job_canceled(jcr)) {
+      return 1;
+   }
+
+   /* TODO: return the list to the FD */
+   if (num_fields == 2) 
+      Qmsg(jcr, M_INFO, 0, "      %s%s\n", row[0]?row[0]:"", row[1]?row[1]:"");
+   else
+      Qmsg(jcr, M_INFO, 0, "      %s\n", row[0]?row[0]:"");
+ 
+   return 0;
+}
+
+/* TODO: tweak verify code to use the same function */
+bool accurate_check_file(JCR *jcr, FILE_DBR *fdbr, char *attr, char *Opts_Digest, int *do_Digest)
+{
+   char *p;
+   int stat=false;
+   struct stat statf;                 /* file stat */
+   struct stat statc;                 /* catalog stat */
+
+   int32_t LinkFIf, LinkFIc;
+
+   decode_stat(attr, &statf, &LinkFIf);  /* decode file stat packet */
+   decode_stat(fdbr->LStat, &statc, &LinkFIc); /* decode catalog stat */
+   *do_Digest = CRYPTO_DIGEST_NONE;
+
+   for (p=Opts_Digest; *p; p++) {
+      char ed1[30], ed2[30];
+      switch (*p) {
+      case 'i':                /* compare INODEs */
+	 if (statc.st_ino != statf.st_ino) {
+	    Jmsg(jcr, M_INFO, 0, _("      st_ino   differ. Cat: %s File: %s\n"),
+		 edit_uint64((uint64_t)statc.st_ino, ed1),
+		 edit_uint64((uint64_t)statf.st_ino, ed2));
+	    stat = true;
+	 }
+	 break;
+      case 'p':                /* permissions bits */
+	 if (statc.st_mode != statf.st_mode) {
+	    Jmsg(jcr, M_INFO, 0, _("      st_mode  differ. Cat: %x File: %x\n"),
+		 (uint32_t)statc.st_mode, (uint32_t)statf.st_mode);
+	    stat = true;
+	 }
+	 break;
+      case 'n':                /* number of links */
+	 if (statc.st_nlink != statf.st_nlink) {
+	    Jmsg(jcr, M_INFO, 0, _("      st_nlink differ. Cat: %d File: %d\n"),
+		 (uint32_t)statc.st_nlink, (uint32_t)statf.st_nlink);
+	    stat = true;
+	 }
+	 break;
+      case 'u':                /* user id */
+	 if (statc.st_uid != statf.st_uid) {
+	    Jmsg(jcr, M_INFO, 0, _("      st_uid   differ. Cat: %u File: %u\n"),
+		 (uint32_t)statc.st_uid, (uint32_t)statf.st_uid);
+	    stat = true;
+	 }
+	 break;
+      case 'g':                /* group id */
+	 if (statc.st_gid != statf.st_gid) {
+	    Jmsg(jcr, M_INFO, 0, _("      st_gid   differ. Cat: %u File: %u\n"),
+		 (uint32_t)statc.st_gid, (uint32_t)statf.st_gid);
+	    stat = true;
+	 }
+	 break;
+      case 's':                /* size */
+	 if (statc.st_size != statf.st_size) {
+	    Jmsg(jcr, M_INFO, 0, _("      st_size  differ. Cat: %s File: %s\n"),
+		 edit_uint64((uint64_t)statc.st_size, ed1),
+		 edit_uint64((uint64_t)statf.st_size, ed2));
+	    stat = true;
+	 }
+	 break;
+      case 'a':                /* access time */
+	 if (statc.st_atime != statf.st_atime) {
+	    Jmsg(jcr, M_INFO, 0, _("      st_atime differs\n"));
+	    stat = true;
+	 }
+	 break;
+      case 'm':
+	 if (statc.st_mtime != statf.st_mtime) {
+	    Jmsg(jcr, M_INFO, 0, _("      st_mtime differs\n"));
+	    stat = true;
+	 }
+	 break;
+      case 'c':                /* ctime */
+	 if (statc.st_ctime != statf.st_ctime) {
+	    Jmsg(jcr, M_INFO, 0, _("      st_ctime differs\n"));
+	    stat = true;
+	 }
+	 break;
+      case 'd':                /* file size decrease */
+	 if (statc.st_size > statf.st_size) {
+	    Jmsg(jcr, M_INFO, 0, _("      st_size  decrease. Cat: %s File: %s\n"),
+		 edit_uint64((uint64_t)statc.st_size, ed1),
+		 edit_uint64((uint64_t)statf.st_size, ed2));
+	    stat = true;
+	 }
+	 break;
+      case '5':                /* compare MD5 */
+	 Dmsg1(500, "set Do_MD5 for %s\n", jcr->fname);
+	 *do_Digest = CRYPTO_DIGEST_MD5;
+	 break;
+      case '1':                 /* compare SHA1 */
+	 *do_Digest = CRYPTO_DIGEST_SHA1;
+	 break;
+      case ':':
+      case 'V':
+      default:
+	 break;
+      }
+   }
+   return stat;
+}
+
+/*
+ * This function is called at EOJ.
+ *  For a Full backup, we remove old one, and we add all entries 
+ *  For an Incremental, we add all entries (delete have been before)
+ *  For a Differential, we add all entries (delete have been before)
+ * 
+ * TODO: 
+ *      
+ */
+bool accurate_update_current_files(JCR *jcr)
+{
+   JobId_t backupid;
+
+   if (jcr->accurate == false) {
+      return true;
+   }
+
+   backupid = db_accurate_find_backupid(jcr, jcr->db, &jcr->jr);
+
+   Dmsg1(1, "backupid = %i\n", backupid);
+
+   if (!backupid) {
+      return false;		/* something goes wrong */
+   }
+
+   if (jcr->JobLevel == L_FULL) {
+      db_accurate_cleanup_currentfile(jcr, jcr->db, backupid);
+   }
+
+   db_accurate_update_currentfile(jcr, jcr->db, jcr->JobId, 
+				  jcr->JobLevel, backupid);
+   return true;
+}
+
+/*
+ * We are called here for each record that matches the above
+ *  SQL query -- that is for each file contained in the Catalog
+ *  that was not marked earlier. This means that the file in
+ *  question is a missing file (in the Catalog but not on Disk).
+ */
+static int accurate_handler(void *ctx, int num_fields, char **row)
+{
+   JCR *jcr = (JCR *)ctx;
+
+   if (job_canceled(jcr)) {
+      return 1;
+   }
+   if (num_fields == 2) {	/* deleted files */
+      jcr->file_bsock->fsend("D %s%s", row[0]?row[0]:"", row[1]?row[1]:""); 
+   } else if (num_fields == 1) { /* files to backup */
+      jcr->file_bsock->fsend("S %s", row[0]?row[0]:""); 
+   }
+   return 0;
+}
+
+/*
+ * Send deleted files and files to backup in accurate mode
+ *
+ */
+static int accurate_send_missing_and_deleted_files(JCR *jcr, JobId_t BackupId)
+{
+   char buf[MAXSTRING];
+   char ed1[50], ed2[50];
+
+   bsnprintf(buf, sizeof(buf),
+      "SELECT Path.Path,Filename.Name "
+        "FROM CurrentFile "
+             "JOIN File USING (FileId) "
+             "JOIN Path USING (PathId) "
+             "JOIN Filename USING (FilenameId) "
+      "WHERE CurrentFile.BackupId=%s "
+        "AND CurrentFile.MarkId!=%s ",
+	     edit_uint64(BackupId, ed1), edit_uint64(jcr->JobId, ed2));
+   /* missing_handler is called for each file found */
+   Dmsg1(2, "display deleted files cmd=%s\n", buf);
+   db_sql_query(jcr->db, buf, accurate_handler, (void *)jcr);
+   jcr->file_bsock->signal(BNET_EOD);
+   
+   bsnprintf(buf, sizeof(buf),
+	     "SELECT Name FROM ToBackup%s",
+	     edit_uint64(jcr->JobId, ed2));
+   /* missing_handler is called for each file found */
+   Dmsg1(2, "display files to backup cmd=%s\n", buf);
+   db_sql_query(jcr->db, buf, accurate_handler, (void *)jcr);
+   jcr->file_bsock->signal(BNET_EOD);
+
+   return 1;
+}
+
+/*
+ * Accurate backup mode
+ * 1. Receive the list of all files including those backed up to the Dir
+ * 2. Dir computes files and deleted files.
+ * 3. Dir sends list of additional files (new files) to backup, and list of files
+ *    deleted.
+ *
+ * Cleanup attributes (don't use atime, inode etc..)
+ * Need to insert file and attributes to temp table ?
+ * Batch compare files and attributes ?
+ *
+ * If file have file_index=0, they are discarded by FD
+ *
+ * TODO: send deleted list and new list to client
+ *       tweak SD with file_index=-1
+ */
+bool accurate_compute_files(JCR *jcr)
+{
+   BSOCK   *fd;
+   char buf[MAXSTRING];
+   int n, len;
+   FILE_DBR fdbr;
+   POOLMEM *fname = get_pool_memory(PM_MESSAGE);
+   int do_Digest = CRYPTO_DIGEST_NONE;
+   int32_t file_index = 0;
+   JobId_t JobId=0;		/* TODO: compute the job key in new table */
+   JobId_t backupid=0;
+
+   memset(&fdbr, 0, sizeof(FILE_DBR));
+   fd = jcr->file_bsock;
+   fdbr.JobId = JobId;		
+   jcr->FileIndex = 0;
+
+   if (jcr->accurate == false || jcr->JobLevel == L_FULL) {
+      return true;
+   }
+
+   backupid = db_accurate_find_backupid(jcr, jcr->db, &jcr->jr);
+   if (!backupid) {
+      Jmsg(jcr, M_ERROR, 0, _("Can't use Accurate mode ERR=Can't find BackupId\n"));
+      return false;
+   }
+   db_accurate_create_tobackup_table(jcr, jcr->db, jcr->JobId);
+   Dmsg0(1, "bdird: waiting to receive file attributes\n");
+   /*
+    * Get Attributes and Signature from File daemon
+    * We expect:
+    *   FileIndex
+    *   Stream
+    *   Options or Digest (MD5/SHA1)
+    *   Filename
+    *   Attributes
+    *   Link name  ???
+    */
+   while ((n=bget_dirmsg(fd)) >= 0 && !job_canceled(jcr)) {
+      int stream;
+      char *attr, *p, *fn;
+      char Opts_Digest[MAXSTRING];        /* Verify Opts or MD5/SHA1 digest */
+
+      if (job_canceled(jcr)) {
+         goto bail_out2;
+      }
+      fname = check_pool_memory_size(fname, fd->msglen);
+      jcr->fname = check_pool_memory_size(jcr->fname, fd->msglen);
+      Dmsg1(1, "Atts+Digest=%s\n", fd->msg);
+      if ((len = sscanf(fd->msg, "%ld %d %100s", &file_index, &stream,
+            fname)) != 3) {
+         Jmsg3(jcr, M_FATAL, 0, _("bird<filed: bad attributes, expected 3 fields got %d\n"
+" mslen=%d msg=%s\n"), len, fd->msglen, fd->msg);
+         goto bail_out2;
+      }
+      /*
+       * We read the Options or Signature into fname
+       *  to prevent overrun, now copy it to proper location.
+       */
+      bstrncpy(Opts_Digest, fname, sizeof(Opts_Digest));
+      p = fd->msg;
+      skip_nonspaces(&p);             /* skip FileIndex */
+      skip_spaces(&p);
+      skip_nonspaces(&p);             /* skip Stream */
+      skip_spaces(&p);
+      skip_nonspaces(&p);             /* skip Opts_Digest */
+      p++;                            /* skip space */
+      fn = fname;
+      while (*p != 0) {
+         *fn++ = *p++;                /* copy filename */
+      }
+      *fn = *p++;                     /* term filename and point to attribs */
+      attr = p;
+      /*
+       * Got attributes stream, decode it
+       */
+      if (stream == STREAM_UNIX_ATTRIBUTES || stream == STREAM_UNIX_ATTRIBUTES_EX) {
+	 int changed=true;
+         Dmsg2(400, "file_index=%d attr=%s\n", file_index, attr);
+         jcr->JobFiles++;
+         jcr->FileIndex = file_index;    /* remember attribute file_index */
+         do_Digest = CRYPTO_DIGEST_NONE;
+         pm_strcpy(jcr->fname, fname);  /* move filename into JCR */
+	 fdbr.FileId = 0;
+
+         /*
+          * Find equivalent record in the database
+          */
+	 
+	 if (db_accurate_get_file_attributes_record(jcr, jcr->db, jcr->fname,
+						    backupid, &fdbr))
+	 {
+	    Dmsg2(1, "get_file ok fname=%s fileid=%i\n", jcr->fname, fdbr.FileId);
+	    if (fdbr.MarkId != jcr->JobId) {	       /* Already visited ? */
+	       if (file_index == 0) { /* file not saved */
+		  changed = accurate_check_file(jcr, &fdbr, attr, Opts_Digest, &do_Digest);
+		  Dmsg1(1, "check_file changed=%i\n", changed);
+		  
+		  if (changed == true) {
+		     db_accurate_mark_file_for_backup(jcr, jcr->db, jcr->fname, jcr->JobId);
+		     db_accurate_delete_file_record(jcr, jcr->db, fdbr.FileId, backupid);
+		  } else {
+		     db_accurate_mark_file_record(jcr, jcr->db, backupid,
+						  fdbr.FileId, jcr->JobId);
+		  }
+	       } else {		/* file_index != 0 file have be backuped */
+		  db_accurate_delete_file_record(jcr, jcr->db, fdbr.FileId, backupid);
+	       }
+	    }
+	 } else if (file_index == 0) {
+	       Dmsg1(1, "mark_for_backup fname=%s\n", jcr->fname);
+	       db_accurate_mark_file_for_backup(jcr, jcr->db, jcr->fname, jcr->JobId);
+	 }
+      
+      /*
+       * Got Digest Signature from Storage daemon
+       *  It came across in the Opts_Digest field.
+       */
+	 /* not used */
+      } else if (crypto_digest_stream_type(stream) != CRYPTO_DIGEST_NONE) {
+         Dmsg2(400, "stream=Digest inx=%d Digest=%s\n", file_index, Opts_Digest);
+         /*
+          * When ever we get a digest it MUST have been
+          * preceded by an attributes record, which sets attr_file_index
+          */
+         if (jcr->FileIndex != (uint32_t)file_index) {
+            Jmsg2(jcr, M_FATAL, 0, _("MD5/SHA1 index %d not same as attributes %d\n"),
+               file_index, jcr->FileIndex);
+            goto bail_out2;
+         }
+         if (do_Digest != CRYPTO_DIGEST_NONE) {
+            db_escape_string(jcr, jcr->db, buf, Opts_Digest, strlen(Opts_Digest));
+            if (strcmp(buf, fdbr.Digest) != 0) {
+               if (debug_level >= 10) {
+                  Jmsg(jcr, M_INFO, 0, _("      %d not same. File=%s Cat=%s\n"),
+                       stream, buf, fdbr.Digest);
+               } else {
+                  Jmsg(jcr, M_INFO, 0, _("      %d differs.\n"),
+                       stream);
+               }
+               //stat = JS_Differences;
+            }
+            do_Digest = CRYPTO_DIGEST_NONE;
+         }
+      }
+//      jcr->JobFiles = file_index;
+   }
+   if (is_bnet_error(fd)) {
+      berrno be;
+      Jmsg2(jcr, M_FATAL, 0, _("bdird<filed: bad attributes from filed n=%d : %s\n"),
+                        n, be.bstrerror());
+      goto bail_out2;
+   }
+
+/*
+CREATE  VIEW cf AS SELECT path.path || filename.name as filename, 
+       jobid, currentfile.markid, backupid 
+  FROM File join currentfile using (fileid) join filename using (filenameid) join path using (pathid)
+*/
+
+   accurate_send_missing_and_deleted_files(jcr, backupid);
+
+   db_accurate_clean_deleted_files(jcr, jcr->db, jcr->JobId, backupid);
+
+   db_accurate_drop_tobackup_table(jcr, jcr->db, jcr->JobId);
+
+   free_pool_memory(fname);
+   return true;
+
+bail_out2:
+   db_accurate_drop_tobackup_table(jcr, jcr->db, jcr->JobId);
+   return false;
+}
+
+/*
  * Do a backup of the specified FileSet
  *
  *  Returns:  false on failure
@@ -231,9 +637,18 @@
       goto bail_out;
    }
 
+   /*
+    * If backup is in accurate mode, FD will send the list of
+    * all files. We have to store it, and compute witch files
+    * have been deleted and witch files have to be backuped.
+    */
+   accurate_compute_files(jcr);
+
    /* Pickup Job termination data */
    stat = wait_for_job_termination(jcr);
    db_write_batch_file_records(jcr);    /* used by bulk batch file insert */
+   accurate_update_current_files(jcr);
+
    if (stat == JS_Terminated) {
       backup_cleanup(jcr, stat);
       return true;
Index: src/dird/job.c
===================================================================
--- src/dird/job.c	(révision 6372)
+++ src/dird/job.c	(copie de travail)
@@ -979,6 +979,7 @@
    jcr->spool_data = job->spool_data;
    jcr->spool_size = job->spool_size;
    jcr->write_part_after_job = job->write_part_after_job;
+   jcr->accurate = job->accurate;
    if (jcr->RestoreBootstrap) {
       free(jcr->RestoreBootstrap);
       jcr->RestoreBootstrap = NULL;
Index: src/dird/inc_conf.c
===================================================================
--- src/dird/inc_conf.c	(révision 6372)
+++ src/dird/inc_conf.c	(copie de travail)
@@ -94,6 +94,7 @@
  * Items that are valid in an Options resource
  */
 static RES_ITEM options_items[] = {
+   {"accurate",        store_opts,    {0},     0, 0, 0},
    {"compression",     store_opts,    {0},     0, 0, 0},
    {"signature",       store_opts,    {0},     0, 0, 0},
    {"verify",          store_opts,    {0},     0, 0, 0},
@@ -153,7 +154,8 @@
    INC_KW_NOATIME,
    INC_KW_ENHANCEDWILD,
    INC_KW_CHKCHANGES,
-   INC_KW_STRIPPATH
+   INC_KW_STRIPPATH,
+   INC_KW_ACCURATE
 };
 
 /*
@@ -163,6 +165,7 @@
  *   options given above.
  */
 static struct s_kw FS_option_kw[] = {
+   {"accurate",    INC_KW_ACCURATE},
    {"compression", INC_KW_COMPRESSION},
    {"signature",   INC_KW_DIGEST},
    {"encryption",  INC_KW_ENCRYPTION},
@@ -251,6 +254,8 @@
    {"no",       INC_KW_ENHANCEDWILD,  "0"},
    {"yes",      INC_KW_CHKCHANGES,    "c"},
    {"no",       INC_KW_CHKCHANGES,    "0"},
+   {"yes",      INC_KW_ACCURATE,      "C"},
+   {"no",       INC_KW_ACCURATE,      "0"},
    {NULL,       0,                      0}
 };
 
Index: src/dird/dird_conf.c
===================================================================
--- src/dird/dird_conf.c	(révision 6372)
+++ src/dird/dird_conf.c	(copie de travail)
@@ -319,6 +319,7 @@
    {"selectionpattern", store_str, ITEM(res_job.selection_pattern), 0, 0, 0},
    {"runscript", store_runscript, ITEM(res_job.RunScripts), 0, ITEM_NO_EQUALS, 0},
    {"selectiontype", store_migtype, ITEM(res_job.selection_type), 0, 0, 0},
+   {"accurate", store_bool, ITEM(res_job.accurate), 0,0,0},
    {NULL, NULL, {0}, 0, 0, 0}
 };
 
@@ -618,6 +619,9 @@
       if (res->res_job.spool_size) {
          sendit(sock, _("     SpoolSize=%s\n"),        edit_uint64(res->res_job.spool_size, ed1));
       }
+      if (res->res_job.JobType == JT_BACKUP) {
+	 sendit(sock, _("     Accurate=%d\n"), res->res_job.accurate);
+      }
       if (res->res_job.JobType == JT_MIGRATE) {
          sendit(sock, _("     SelectionType=%d\n"), res->res_job.selection_type);
       }
Index: src/dird/dird_conf.h
===================================================================
--- src/dird/dird_conf.h	(révision 6372)
+++ src/dird/dird_conf.h	(copie de travail)
@@ -400,6 +400,7 @@
    bool write_part_after_job;         /* Set to write part after job in SD */
    bool enabled;                      /* Set if job enabled */
    bool OptimizeJobScheduling;        /* Set if we should optimize Job scheduling */
+   bool accurate;                     /* Set if it is an accurate backup job */
    
    MSGS      *messages;               /* How and where to send messages */
    SCHED     *schedule;               /* When -- Automatic schedule */
Index: src/filed/backup.c
===================================================================
--- src/filed/backup.c	(révision 6372)
+++ src/filed/backup.c	(copie de travail)
@@ -50,6 +50,109 @@
 static bool crypto_session_send(JCR *jcr, BSOCK *sd);
 
 /*
+ * Called by save_file when accept/discard file for backup
+ *
+ * TODO: we could add MD5/SHAX digest, but we have to compute it
+ * for all files.
+ */
+static bool accurate_add_file(JCR *jcr, FF_PKT *ff_pkt, char *stats)
+{
+   char *a=stats;
+   char attribs[MAXSTRING];
+   uint32_t file_index=jcr->JobFiles;
+   BSOCK *dir = jcr->dir_bsock;
+   int stat;
+
+   if (jcr->accurate == false || jcr->JobLevel == L_FULL) {
+      return true;
+   }
+
+   if (!stats) {		/* TODO: don't always compute attribute  */
+      file_index=0;
+      encode_stat(attribs, ff_pkt, 0);
+      a = attribs;
+   }
+
+   switch (ff_pkt->type) {
+   case FT_LNKSAVED:                  /* Hard linked, file already saved */
+   case FT_LNK:
+      stat = dir->fsend("%d %d %s %s%c%s%c%s%c", file_index,
+            STREAM_UNIX_ATTRIBUTES, ff_pkt->VerifyOpts, ff_pkt->fname,
+            0, a, 0, ff_pkt->link, 0);
+      break;
+   case FT_REGE:
+   case FT_REG:
+   case FT_SPEC:
+   case FT_RAW:
+   case FT_FIFO:
+   case FT_NOCHG:
+      stat = dir->fsend("%d %d %s %s%c%s%c%c", file_index,
+            STREAM_UNIX_ATTRIBUTES, ff_pkt->VerifyOpts, ff_pkt->fname,
+            0, a, 0, 0);
+
+      break;
+   case FT_REPARSE: 
+   case FT_DIREND:
+   case FT_NORECURSE:
+   case FT_DIRNOCHG:
+      stat = dir->fsend("%d %d %s %s%c%s%c%c", file_index,
+               STREAM_UNIX_ATTRIBUTES, ff_pkt->VerifyOpts, ff_pkt->link,
+               0, a, 0, 0);
+      break;
+   default:
+      Dmsg2(1, _("Fname=%s Type=%i\n"), ff_pkt->fname, ff_pkt->type);
+      return true;
+   }
+
+   if (!stat) {
+      Jmsg(jcr, M_FATAL, 0, _("Network error in send to Director: ERR=%s\n"), bnet_strerror(dir));
+      return 0;
+   }
+
+   return true;
+}
+
+/* build a fileset with new files from director */
+static bool accurate_get_new_and_deleted_file_list(JCR *jcr)
+{   
+   BSOCK *dir = jcr->dir_bsock;
+   if (jcr->accurate == false || job_canceled(jcr)) {
+      return true;
+   }
+
+   /* get deleted files */
+   while (dir->recv() >= 0) {
+      Dmsg1(1, "deleted = %s\n", dir->msg);
+   }
+   /* get missing files */
+   while (dir->recv() >= 0) {
+      Dmsg1(1, "missing = %s\n", dir->msg);
+   }
+   
+   return true;
+}
+
+/* send deleted file list to stored */
+static bool accurate_send_deleted_list(JCR *jcr)
+{
+   if (jcr->accurate == false || job_canceled(jcr)) {
+      return true;
+   }
+   return true;
+}
+
+static bool accurate_send_file_list(JCR *jcr)
+{
+   if (jcr->accurate == false || job_canceled(jcr)) {
+      return true;
+   }
+   Dmsg0(1, "Sending BNET_EOD\n");
+   jcr->dir_bsock->signal(BNET_EOD);            /* end of sending data */
+   return true;
+}
+
+
+/*
  * Find all the requested files and send them
  * to the Storage daemon.
  *
@@ -66,7 +169,6 @@
    BSOCK *sd;
    bool ok = true;
    // TODO landonf: Allow user to specify encryption algorithm
-
    sd = jcr->store_bsock;
 
    set_jcr_job_status(jcr, JS_Running);
@@ -134,6 +236,20 @@
       ok = false;                     /* error */
       set_jcr_job_status(jcr, JS_ErrorTerminated);
    }
+   Dmsg1(1, "jcr->accurate == %i\n", jcr->accurate);
+   /* start accurate stuffs */
+   if (jcr->accurate) {
+      /* TODO: test job_canceled() */
+      accurate_send_file_list(jcr);                 /* send all files to DIR */
+      accurate_get_new_and_deleted_file_list(jcr);  /* get a new incr fileset from DIR */
+//      set_find_options((FF_PKT *)jcr->ff, 0, 0);            /* we backup all that director wants */
+//      if (!find_files(jcr, (FF_PKT *)jcr->ff, save_file)) {
+//	 ok = false;                     /* error */
+//	 set_jcr_job_status(jcr, JS_ErrorTerminated);
+//      }
+//      accurate_send_file_list(jcr);                 /* send all new files to DIR */
+      accurate_send_deleted_list(jcr);              /* send deleted list to SD  */
+   }
 
    free_pool_memory(jcr->acl_text);
 
@@ -355,9 +471,11 @@
    case FT_DIRNOCHG:
    case FT_NOCHG:
       Jmsg(jcr, M_SKIPPED, 1, _("     Unchanged file skipped: %s\n"), ff_pkt->fname);
+      accurate_add_file(jcr, ff_pkt, NULL); /* list skipped files */
       return 1;
    case FT_ISARCH:
       Jmsg(jcr, M_NOTSAVED, 0, _("     Archive file not saved: %s\n"), ff_pkt->fname);
+      accurate_add_file(jcr, ff_pkt, NULL); /* list skipped files */
       return 1;
    case FT_NOOPEN: {
       berrno be;
@@ -1111,6 +1229,9 @@
    }
    unstrip_path(ff_pkt);
 
+   /* list backuped files */
+   accurate_add_file(jcr, ff_pkt, attribs);
+
    Dmsg2(300, ">stored: attr len=%d: %s\n", sd->msglen, sd->msg);
    if (!stat) {
       Jmsg1(jcr, M_FATAL, 0, _("Network send error to SD. ERR=%s\n"),
Index: src/filed/job.c
===================================================================
--- src/filed/job.c	(révision 6372)
+++ src/filed/job.c	(copie de travail)
@@ -1087,6 +1087,9 @@
       case 'c':
          fo->flags |= FO_CHKCHANGES;
          break;
+      case 'C':
+         fo->flags |= FO_ACCURATE;
+         break;
       default:
          Emsg1(M_ERROR, 0, _("Unknown include/exclude option: %c\n"), *p);
          break;
@@ -1195,6 +1198,9 @@
 
    level = get_memory(dir->msglen+1);
    Dmsg1(110, "level_cmd: %s", dir->msg);
+   if (strstr(dir->msg, "accurate")) {
+      jcr->accurate = true;
+   }
    if (sscanf(dir->msg, "level = %s ", level) != 1) {
       goto bail_out;
    }
@@ -1204,14 +1210,14 @@
    /* Full backup requested? */
    } else if (strcmp(level, "full") == 0) {
       jcr->JobLevel = L_FULL;
-   } else if (strcmp(level, "differential") == 0) {
+   } else if (strstr(level, "differential")) {
       jcr->JobLevel = L_DIFFERENTIAL;
       free_memory(level);
       return 1;
-   } else if (strcmp(level, "incremental") == 0) {
+   } else if (strstr(level, "incremental")) {
       jcr->JobLevel = L_INCREMENTAL;
       free_memory(level);
-      return 1;   
+      return 1;
    /*
     * We get his UTC since time, then sync the clocks and correct it
     *   to agree with our clock.
Index: src/cats/sql_update.c
===================================================================
--- src/cats/sql_update.c	(révision 6372)
+++ src/cats/sql_update.c	(copie de travail)
@@ -88,6 +88,102 @@
    return stat;
 }
 
+int db_accurate_delete_file_record(JCR *jcr, B_DB *mdb, FileId_t FileId, JobId_t BackupId)
+{
+   int stat;
+   char ed1[50], ed2[50];
+   db_lock(mdb);
+   Mmsg(mdb->cmd, "DELETE FROM CurrentFile WHERE FileId=%s AND BackupId=%s",
+	edit_int64(FileId, ed1), edit_int64(BackupId, ed2));
+   stat = INSERT_DB(jcr, mdb, mdb->cmd);
+   db_unlock(mdb);
+   return stat;
+}
+
+int db_accurate_mark_file_for_backup(JCR *jcr, B_DB *mdb, char *fname, JobId_t JobId)
+{
+   int stat;
+   char ed1[50];
+   db_lock(mdb);
+   /* TODO: mdb->esc_xxx are already ok but it's more smart to recompute it */
+//   mdb->esc_name = check_pool_memory_size(mdb->esc_name, 2*len+2);
+//   mdb->esc_name = db_escape_string(jcr, mdb, mdb->esc_name, fname, len);
+   Mmsg(mdb->cmd, "INSERT INTO ToBackup%s (name) VALUES ('%s%s')", edit_int64(JobId, ed1), mdb->esc_path, mdb->esc_name);
+   stat = INSERT_DB(jcr, mdb, mdb->cmd);
+   db_unlock(mdb);
+   return stat;
+}
+
+int db_accurate_cleanup_currentfile(JCR *jcr, B_DB *mdb, JobId_t BackupId)
+{
+   int stat;
+   char ed1[50];
+   db_lock(mdb);
+   Mmsg(mdb->cmd, "DELETE FROM CurrentFile WHERE BackupId=%s", edit_int64(BackupId, ed1));
+   stat = QUERY_DB(jcr, mdb, mdb->cmd);
+   db_unlock(mdb);
+   return stat;
+}
+
+int db_accurate_update_currentfile(JCR *jcr, B_DB *mdb, JobId_t JobId, int JobLevel, JobId_t BackupId)
+{
+   int stat;
+   char ed1[50], ed2[50], ed3[50];
+   db_lock(mdb);
+   edit_int64(JobId, ed2);
+   Mmsg(mdb->cmd, 
+	"INSERT INTO CurrentFile (FileId, BackupId, FullMark, MarkId) "
+	" (SELECT FileId, %s, '%c', %s FROM File WHERE JobId=%s)", 
+	edit_int64(BackupId, ed1),
+	JobLevel, ed2, ed2);
+   stat = QUERY_DB(jcr, mdb, mdb->cmd);
+   db_unlock(mdb);
+   return stat; 
+}
+
+int db_accurate_create_tobackup_table(JCR *jcr, B_DB *mdb, JobId_t JobId)
+{
+   int stat;
+   char ed1[50];
+   db_lock(mdb);
+   Mmsg(mdb->cmd, "CREATE TABLE ToBackup%s (name text)", edit_int64(JobId, ed1));
+//   Mmsg(mdb->cmd, "CREATE TEMPORARY TABLE ToBackup%s (name text)", edit_int64(JobId, ed1));
+   stat = QUERY_DB(jcr, mdb, mdb->cmd);
+   db_unlock(mdb);
+   return stat;
+}
+
+int db_accurate_drop_tobackup_table(JCR *jcr, B_DB *mdb, JobId_t JobId)
+{
+   int stat=0;
+   char ed1[50];
+   db_lock(mdb);
+//   Mmsg(mdb->cmd, "DROP TABLE ToBackup%s", edit_int64(JobId, ed1));
+//   stat = QUERY_DB(jcr, mdb, mdb->cmd);
+   db_unlock(mdb);
+   return stat;
+}
+
+
+/* Mark the file record as being visited during database
+ * accurate compare. Stuff JobId into the MarkId field
+ */
+int db_accurate_mark_file_record(JCR *jcr, B_DB *mdb, JobId_t BackupId, FileId_t FileId, JobId_t JobId)
+{
+   int stat;
+   char ed1[50], ed2[50], ed3[50];
+
+   db_lock(mdb);
+   Mmsg(mdb->cmd, "UPDATE CurrentFile SET MarkId=%s WHERE FileId=%s AND BackupId=%s", 
+	edit_int64(JobId, ed1), edit_int64(FileId, ed2), edit_int64(BackupId, ed3));
+   stat = QUERY_DB(jcr, mdb, mdb->cmd);
+   if (!stat || sql_affected_rows(mdb) != 1) {
+      stat = 0;
+   }
+   db_unlock(mdb);
+   return stat;
+}
+
 /*
  * Update the Job record at start of Job
  *
Index: src/cats/make_postgresql_tables.in
===================================================================
--- src/cats/make_postgresql_tables.in	(révision 6372)
+++ src/cats/make_postgresql_tables.in	(copie de travail)
@@ -43,6 +43,59 @@
 CREATE INDEX file_jobid_idx on file (jobid);
 CREATE INDEX file_fp_idx on file (filenameid, pathid);
 
+CREATE TABLE CurrentBackupId
+(
+     BackupId          serial     not null,
+     ClientId          integer    not null,
+     JobName           text       not null,
+     FileSetId         integer    not null,
+     primary key (BackupId)
+);
+
+-- Serait bien de prendre la meme table pour
+-- les File et le CurrentBackup...
+-- Mais y'a des problemes pour les prunes
+
+CREATE TABLE CurrentFile
+(
+     FileId           integer    not null,
+     BackupId         integer    not null,
+     FullMark         char(1)    default 0,
+     MarkId           integer    default 0,
+     primary key (FileId)
+);
+
+CREATE INDEX currentfile_fileid on CurrentFile (BackupId);
+
+-- CREATE TEMPORARY TABLE batch (fileindex int,
+--                               jobid int,
+--                               path varchar,
+--                               name varchar,
+--                               lstat varchar,
+--                               md5 varchar);
+-- 
+-- -- On batch insert dans la table temporaire
+
+-- il faut trouver les fichiers manquant
+-- INSERT des nouveaux, UPDATE des anciens, SELECT pour trouver les deletes
+
+
+-- il faut trouver les fichiers modifies
+-- Le champs LStat n'est plus le meme
+-- SELECT * 
+--   FROM CurrentBackup, 
+--        batch JOIN Path USING (Path) JOIN Filename USING (Name)
+--  WHERE Path.PathId = CurrentBackup.PathId
+--    AND Filename.FilenameId = CurrentBackup.FilenameId
+--    AND CurrentBackup.LStat != batch.LStat
+-- 
+-- il faut mettre a jour la liste des fichiers
+
+
+
+
+
+
 --
 -- Possibly add one or more of the following indexes
 --  if your Verifies are too slow.
Index: src/cats/protos.h
===================================================================
--- src/cats/protos.h	(révision 6372)
+++ src/cats/protos.h	(copie de travail)
@@ -78,14 +78,17 @@
 /* sql_delete.c */
 int db_delete_pool_record(JCR *jcr, B_DB *db, POOL_DBR *pool_dbr);
 int db_delete_media_record(JCR *jcr, B_DB *mdb, MEDIA_DBR *mr);
+int db_accurate_clean_deleted_files(JCR *jcr, B_DB *mdb, JobId_t JobId, JobId_t BackupId);
 
 /* sql_find.c */
 bool db_find_job_start_time(JCR *jcr, B_DB *mdb, JOB_DBR *jr, POOLMEM **stime);
 bool db_find_last_jobid(JCR *jcr, B_DB *mdb, const char *Name, JOB_DBR *jr);
+JobId_t db_accurate_find_backupid(JCR *jcr, B_DB *mdb, JOB_DBR *jr);
 int db_find_next_volume(JCR *jcr, B_DB *mdb, int index, bool InChanger, MEDIA_DBR *mr);
 bool db_find_failed_job_since(JCR *jcr, B_DB *mdb, JOB_DBR *jr, POOLMEM *stime, int &JobLevel);
 
 /* sql_get.c */
+int db_accurate_get_file_attributes_record(JCR *jcr, B_DB *mdb, char *fname, JobId_t backupid, FILE_DBR *fdbr);
 bool db_get_pool_record(JCR *jcr, B_DB *db, POOL_DBR *pdbr);
 int db_get_client_record(JCR *jcr, B_DB *mdb, CLIENT_DBR *cr);
 bool db_get_job_record(JCR *jcr, B_DB *mdb, JOB_DBR *jr);
@@ -129,6 +132,14 @@
 int  db_update_counter_record(JCR *jcr, B_DB *mdb, COUNTER_DBR *cr);
 int  db_add_digest_to_file_record(JCR *jcr, B_DB *mdb, FileId_t FileId, char *digest, int type);
 int  db_mark_file_record(JCR *jcr, B_DB *mdb, FileId_t FileId, JobId_t JobId);
+int db_accurate_mark_file_for_backup(JCR *jcr, B_DB *mdb, char *fname, FileId_t JobId);
+int db_accurate_mark_file_record(JCR *jcr, B_DB *mdb, JobId_t BackupId, FileId_t FileId, JobId_t JobId);
+int db_accurate_drop_tobackup_table(JCR *jcr, B_DB *mdb, JobId_t JobId);
+int db_accurate_create_tobackup_table(JCR *jcr, B_DB *mdb, JobId_t JobId);
+int db_accurate_delete_file_record(JCR *jcr, B_DB *mdb, FileId_t FileId, JobId_t BackupId);
 void db_make_inchanger_unique(JCR *jcr, B_DB *mdb, MEDIA_DBR *mr);
+int db_accurate_cleanup_currentfile(JCR *jcr, B_DB *mdb, JobId_t BackupId);
+int db_accurate_update_currentfile(JCR *jcr, B_DB *mdb, JobId_t JobId, int JobLevel, JobId_t BackupId);
 
+
 #endif /* __SQL_PROTOS_H */
Index: src/cats/sql_find.c
===================================================================
--- src/cats/sql_find.c	(révision 6372)
+++ src/cats/sql_find.c	(copie de travail)
@@ -190,7 +190,60 @@
    return true;
 }
 
+/*
+ * Find BackupId of last job that ran.  E.g. for
+ *
+ * Returns: Last backuip
+ *
+ */
+JobId_t
+db_accurate_find_backupid(JCR *jcr, B_DB *mdb, JOB_DBR *jr)
+{
+   SQL_ROW row;
+   char ed1[50],ed2[50];
+   JobId_t backupid=0;
 
+   /* Find backupid */
+   db_lock(mdb);
+   Dmsg2(100, "JobLevel=%d JobType=%d\n", jcr->JobLevel, jcr->JobType);
+   Mmsg(mdb->cmd,
+"SELECT BackupId FROM CurrentBackupId WHERE JobName='%s' AND "
+"ClientId=%s AND FileSetId=%s ORDER BY BackupId DESC LIMIT 1",
+	jr->Name, 
+	edit_int64(jr->ClientId, ed1),
+	edit_int64(jr->FileSetId, ed2));
+
+   Dmsg1(100, "Query: %s\n", mdb->cmd);
+   if (!QUERY_DB(jcr, mdb, mdb->cmd)) {
+      db_unlock(mdb);
+      return 0;
+   }
+   if ((row = sql_fetch_row(mdb)) == NULL) {
+      sql_free_result(mdb);
+      if (jcr->JobLevel == L_FULL) {
+	 Mmsg(mdb->cmd,
+	      "INSERT INTO CurrentBackupId (JobName, ClientId, FileSetId) VALUES ('%s', %s, %s)",
+	      jr->Name, ed1, ed2);
+	 if (!INSERT_DB(jcr, mdb, mdb->cmd)) {
+	    db_unlock(mdb);
+	    return 0;
+	 }
+	 backupid = sql_insert_id(mdb, NT_("CurrentBackupId"));
+      } else {
+	 Mmsg1(&mdb->errmsg, _("No Job found for: %s.\n"), mdb->cmd);
+	 backupid = 0;
+      }
+   } else {
+      backupid = str_to_int64(row[0]);
+   }
+
+   sql_free_result(mdb);
+
+   db_unlock(mdb);
+   return backupid;
+}
+
+
 /*
  * Find JobId of last job that ran.  E.g. for
  *   VERIFY_CATALOG we want the JobId of the last INIT.
Index: src/cats/sql_delete.c
===================================================================
--- src/cats/sql_delete.c	(révision 6372)
+++ src/cats/sql_delete.c	(copie de travail)
@@ -236,5 +236,22 @@
    return 1;
 }
 
+/*
+ * Purge delete file from CurrentFile table. This table contains only
+ * current files.
+ */
+int db_accurate_clean_deleted_files(JCR *jcr, B_DB *mdb, JobId_t JobId, JobId_t BackupId)
+{
+   int stat;
+   char ed1[50], ed2[50];
+   db_lock(mdb);
+   Mmsg(mdb->cmd, "DELETE FROM CurrentFile WHERE MarkId!=%s AND BackupId=%s", 
+	edit_int64(JobId, ed1), edit_int64(BackupId, ed2));
+   stat = QUERY_DB(jcr, mdb, mdb->cmd);
+   db_unlock(mdb);
+   return stat;
 
+}
+
+
 #endif /* HAVE_SQLITE3 || HAVE_MYSQL || HAVE_SQLITE || HAVE_POSTGRESQL*/
Index: src/cats/sql_create.c
===================================================================
--- src/cats/sql_create.c	(révision 6372)
+++ src/cats/sql_create.c	(copie de travail)
@@ -829,6 +829,14 @@
    return true;
 }
 
+bool db_accurate_insert(JCR *jcr, B_DB *mdb, bool saved, const char *fname, struct stat *stat)
+{
+   int len;
+   split_path_and_file(jcr, mdb, fname);
+   /* make like in Verify code */
+   return true;
+} 
+
 /*
  * Create File record in B_DB
  *
Index: src/cats/sql_get.c
===================================================================
--- src/cats/sql_get.c	(révision 6372)
+++ src/cats/sql_get.c	(copie de travail)
@@ -66,6 +66,8 @@
  *
  *  Returns: 0 on failure
  *           1 on success with the File record in FILE_DBR
+ *
+ * TODO: optimize this with only one query
  */
 int db_get_file_attributes_record(JCR *jcr, B_DB *mdb, char *fname, JOB_DBR *jr, FILE_DBR *fdbr)
 {
@@ -86,7 +88,73 @@
    return stat;
 }
 
+/*
+ * Given a full filename (with path), look up the File record
+ * (with attributes) in the database.
+ *
+ *  Returns: 0 on failure
+ *           1 on success with the File record in FILE_DBR
+ */
+int db_accurate_get_file_attributes_record(JCR *jcr, B_DB *mdb, char *fname, JobId_t backupid, FILE_DBR *fdbr)
+{
+   int stat=0;
+   char ed1[50];
+   SQL_ROW row;
 
+   db_lock(mdb);
+   split_path_and_file(jcr, mdb, fname);
+
+   mdb->esc_name = check_pool_memory_size(mdb->esc_name, 2*mdb->fnl+2);
+   db_escape_string(jcr, mdb, mdb->esc_name, mdb->fname, mdb->fnl);
+
+   mdb->esc_path = check_pool_memory_size(mdb->esc_path, 2*mdb->pnl+2);
+   db_escape_string(jcr, mdb, mdb->esc_path, mdb->path, mdb->pnl);
+
+   Mmsg(mdb->cmd,
+"SELECT FileId, LStat, MD5, FilenameId, PathId, FileIndex, CurrentFile.MarkId, JobId "
+  "FROM File JOIN CurrentFile USING (FileId) "
+            "JOIN Filename USING (FilenameId) "
+            "JOIN Path     USING (PathId) "
+ "WHERE Path.Path='%s' "
+   "AND Filename.Name='%s' "
+   "AND BackupId=%s ",
+	mdb->esc_path,
+	mdb->esc_name,
+	edit_int64(backupid, ed1));
+   
+   Dmsg1(100,"get_file %s\n", mdb->cmd);
+
+   if (QUERY_DB(jcr, mdb, mdb->cmd)) {
+      char ed1[30];
+      mdb->num_rows = sql_num_rows(mdb);
+      if (mdb->num_rows == 1) {
+         if ((row = sql_fetch_row(mdb)) == NULL) {
+            Mmsg1(mdb->errmsg, _("error fetching row: %s\n"), sql_strerror(mdb));
+         } else {
+	    fdbr->FileId     = str_to_int64(row[0]);
+            bstrncpy(fdbr->LStat, row[1], sizeof(fdbr->LStat));
+            bstrncpy(fdbr->Digest, row[2], sizeof(fdbr->Digest));
+	    fdbr->FilenameId = str_to_int64(row[3]);
+	    fdbr->PathId     = str_to_int64(row[4]);
+	    fdbr->FileIndex  = str_to_int64(row[5]);
+	    fdbr->MarkId     = str_to_int64(row[6]);
+	    fdbr->JobId      = str_to_int64(row[7]);
+	    stat=1;
+	 }
+      } else if (mdb->num_rows > 1) {
+	 Mmsg2(mdb->errmsg, _("Get DB File record %s failed num=%i\n"),fname,mdb->num_rows);
+         Jmsg(jcr, M_WARNING, 0, "%s", mdb->errmsg);
+      }
+      sql_free_result(mdb);
+   } else {
+      Mmsg(mdb->errmsg, _("File record: %s not found in Catalog for BackupId=%s.\n"), fname, ed1);
+   }
+
+   db_unlock(mdb);
+
+   return stat;
+}
+
 /*
  * Get a File record
  * Returns: 0 on failure
Index: src/jcr.h
===================================================================
--- src/jcr.h	(révision 6372)
+++ src/jcr.h	(copie de travail)
@@ -208,6 +208,7 @@
    B_DB *db_batch;                    /* database pointer for batch insert */
    ATTR_DBR *ar;                      /* DB attribute record */
    guid_list *id_list;                /* User/group id to name list */
+   bool accurate;                     /* true if job is accurate */
 
    void *plugin_ctx_list;             /* list of contexts for plugins */
    void *plugin_ctx;                  /* current plugin context */
Index: src/findlib/find.h
===================================================================
--- src/findlib/find.h	(révision 6372)
+++ src/findlib/find.h	(copie de travail)
@@ -108,6 +108,7 @@
 #define FO_ENHANCEDWILD (1<<23)       /* Enhanced wild card processing */
 #define FO_CHKCHANGES   (1<<24)       /* Check if file have been modified during backup */
 #define FO_STRIPPATH    (1<<25)       /* Check for stripping path */
+#define FO_ACCURATE     (1<<26)       /* Accurate mode */
 
 struct s_included_file {
    struct s_included_file *next;
